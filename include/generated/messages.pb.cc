// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "messages.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace protoduck {

namespace {

const ::google::protobuf::Descriptor* Pos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Pos_reflection_ = NULL;
const ::google::protobuf::Descriptor* Speed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Speed_reflection_ = NULL;
const ::google::protobuf::Descriptor* MotorsSpeed_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MotorsSpeed_reflection_ = NULL;
const ::google::protobuf::Descriptor* MotorsCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MotorsCmd_reflection_ = NULL;
const ::google::protobuf::Descriptor* MotorPid_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MotorPid_reflection_ = NULL;
const ::google::protobuf::Descriptor* Bat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Bat_reflection_ = NULL;
const ::google::protobuf::Descriptor* Arm_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Arm_reflection_ = NULL;
const ::google::protobuf::Descriptor* Hat_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Hat_reflection_ = NULL;
const ::google::protobuf::Descriptor* HMI_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HMI_reflection_ = NULL;
const ::google::protobuf::Descriptor* ProcedureCmd_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureCmd_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ProcedureCmd_Procedure_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ProcedureStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ProcedureStatus_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ProcedureStatus_Status_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HexaPos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HexaPos_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HexaPos_HexaType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PlayerPos_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PlayerPos_reflection_ = NULL;
const ::google::protobuf::Descriptor* Message_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Message_reflection_ = NULL;
struct MessageOneofInstance {
  const ::protoduck::Pos* pos_;
  const ::protoduck::Speed* speed_;
  const ::protoduck::MotorsSpeed* motors_speed_;
  const ::protoduck::MotorsCmd* motors_cmd_;
  const ::protoduck::MotorPid* motor_pid_;
  const ::protoduck::Bat* bat_;
  const ::protoduck::Arm* arm_;
  const ::protoduck::Hat* hat_;
  const ::protoduck::HMI* hmi_;
  const ::protoduck::ProcedureCmd* procedure_cmd_;
  const ::protoduck::ProcedureStatus* procedure_status_;
  const ::protoduck::HexaPos* hexa_pos_;
  const ::protoduck::PlayerPos* player_pos_;
}* Message_default_oneof_instance_ = NULL;
const ::google::protobuf::EnumDescriptor* Message_MsgType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Message_Agent_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ArmID_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_messages_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_messages_2eproto() {
  protobuf_AddDesc_messages_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "messages.proto");
  GOOGLE_CHECK(file != NULL);
  Pos_descriptor_ = file->message_type(0);
  static const int Pos_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pos, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pos, y_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pos, theta_),
  };
  Pos_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Pos_descriptor_,
      Pos::default_instance_,
      Pos_offsets_,
      -1,
      -1,
      -1,
      sizeof(Pos),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pos, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Pos, _is_default_instance_));
  Speed_descriptor_ = file->message_type(1);
  static const int Speed_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Speed, vx_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Speed, vy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Speed, vtheta_),
  };
  Speed_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Speed_descriptor_,
      Speed::default_instance_,
      Speed_offsets_,
      -1,
      -1,
      -1,
      sizeof(Speed),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Speed, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Speed, _is_default_instance_));
  MotorsSpeed_descriptor_ = file->message_type(2);
  static const int MotorsSpeed_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsSpeed, v1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsSpeed, v2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsSpeed, v3_),
  };
  MotorsSpeed_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MotorsSpeed_descriptor_,
      MotorsSpeed::default_instance_,
      MotorsSpeed_offsets_,
      -1,
      -1,
      -1,
      sizeof(MotorsSpeed),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsSpeed, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsSpeed, _is_default_instance_));
  MotorsCmd_descriptor_ = file->message_type(3);
  static const int MotorsCmd_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsCmd, cmd1_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsCmd, cmd2_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsCmd, cmd3_),
  };
  MotorsCmd_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MotorsCmd_descriptor_,
      MotorsCmd::default_instance_,
      MotorsCmd_offsets_,
      -1,
      -1,
      -1,
      sizeof(MotorsCmd),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsCmd, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorsCmd, _is_default_instance_));
  MotorPid_descriptor_ = file->message_type(4);
  static const int MotorPid_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, motor_no_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, feedforward_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, kp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, ki_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, kd_),
  };
  MotorPid_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MotorPid_descriptor_,
      MotorPid::default_instance_,
      MotorPid_offsets_,
      -1,
      -1,
      -1,
      sizeof(MotorPid),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MotorPid, _is_default_instance_));
  Bat_descriptor_ = file->message_type(5);
  static const int Bat_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bat, voltage_),
  };
  Bat_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Bat_descriptor_,
      Bat::default_instance_,
      Bat_offsets_,
      -1,
      -1,
      -1,
      sizeof(Bat),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bat, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Bat, _is_default_instance_));
  Arm_descriptor_ = file->message_type(6);
  static const int Arm_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, arm_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, traz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, rotz_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, roty_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, pump_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, valve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, pressure_),
  };
  Arm_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Arm_descriptor_,
      Arm::default_instance_,
      Arm_offsets_,
      -1,
      -1,
      -1,
      sizeof(Arm),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Arm, _is_default_instance_));
  Hat_descriptor_ = file->message_type(7);
  static const int Hat_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, pump_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, valve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, pressure_),
  };
  Hat_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Hat_descriptor_,
      Hat::default_instance_,
      Hat_offsets_,
      -1,
      -1,
      -1,
      sizeof(Hat),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Hat, _is_default_instance_));
  HMI_descriptor_ = file->message_type(8);
  static const int HMI_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, color_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, tirette_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, bouton_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, led_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, hmi_display_),
  };
  HMI_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HMI_descriptor_,
      HMI::default_instance_,
      HMI_offsets_,
      -1,
      -1,
      -1,
      sizeof(HMI),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMI, _is_default_instance_));
  ProcedureCmd_descriptor_ = file->message_type(9);
  static const int ProcedureCmd_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureCmd, arm_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureCmd, procedure_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureCmd, param_),
  };
  ProcedureCmd_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ProcedureCmd_descriptor_,
      ProcedureCmd::default_instance_,
      ProcedureCmd_offsets_,
      -1,
      -1,
      -1,
      sizeof(ProcedureCmd),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureCmd, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureCmd, _is_default_instance_));
  ProcedureCmd_Procedure_descriptor_ = ProcedureCmd_descriptor_->enum_type(0);
  ProcedureStatus_descriptor_ = file->message_type(10);
  static const int ProcedureStatus_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStatus, status_),
  };
  ProcedureStatus_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ProcedureStatus_descriptor_,
      ProcedureStatus::default_instance_,
      ProcedureStatus_offsets_,
      -1,
      -1,
      -1,
      sizeof(ProcedureStatus),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStatus, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ProcedureStatus, _is_default_instance_));
  ProcedureStatus_Status_descriptor_ = ProcedureStatus_descriptor_->enum_type(0);
  HexaPos_descriptor_ = file->message_type(11);
  static const int HexaPos_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HexaPos, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HexaPos, pos_),
  };
  HexaPos_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HexaPos_descriptor_,
      HexaPos::default_instance_,
      HexaPos_offsets_,
      -1,
      -1,
      -1,
      sizeof(HexaPos),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HexaPos, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HexaPos, _is_default_instance_));
  HexaPos_HexaType_descriptor_ = HexaPos_descriptor_->enum_type(0);
  PlayerPos_descriptor_ = file->message_type(12);
  static const int PlayerPos_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerPos, aruco_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerPos, pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerPos, speed_),
  };
  PlayerPos_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PlayerPos_descriptor_,
      PlayerPos::default_instance_,
      PlayerPos_offsets_,
      -1,
      -1,
      -1,
      sizeof(PlayerPos),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerPos, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PlayerPos, _is_default_instance_));
  Message_descriptor_ = file->message_type(13);
  static const int Message_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, msg_type_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, pos_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, speed_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, motors_speed_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, motors_cmd_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, motor_pid_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, bat_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, arm_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, hat_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, hmi_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, procedure_cmd_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, procedure_status_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, hexa_pos_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(Message_default_oneof_instance_, player_pos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, inner_),
  };
  Message_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Message_descriptor_,
      Message::default_instance_,
      Message_offsets_,
      -1,
      -1,
      -1,
      Message_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _oneof_case_[0]),
      sizeof(Message),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Message, _is_default_instance_));
  Message_MsgType_descriptor_ = Message_descriptor_->enum_type(0);
  Message_Agent_descriptor_ = Message_descriptor_->enum_type(1);
  ArmID_descriptor_ = file->enum_type(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_messages_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Pos_descriptor_, &Pos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Speed_descriptor_, &Speed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MotorsSpeed_descriptor_, &MotorsSpeed::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MotorsCmd_descriptor_, &MotorsCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MotorPid_descriptor_, &MotorPid::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Bat_descriptor_, &Bat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Arm_descriptor_, &Arm::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Hat_descriptor_, &Hat::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HMI_descriptor_, &HMI::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ProcedureCmd_descriptor_, &ProcedureCmd::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ProcedureStatus_descriptor_, &ProcedureStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HexaPos_descriptor_, &HexaPos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PlayerPos_descriptor_, &PlayerPos::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Message_descriptor_, &Message::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_messages_2eproto() {
  delete Pos::default_instance_;
  delete Pos_reflection_;
  delete Speed::default_instance_;
  delete Speed_reflection_;
  delete MotorsSpeed::default_instance_;
  delete MotorsSpeed_reflection_;
  delete MotorsCmd::default_instance_;
  delete MotorsCmd_reflection_;
  delete MotorPid::default_instance_;
  delete MotorPid_reflection_;
  delete Bat::default_instance_;
  delete Bat_reflection_;
  delete Arm::default_instance_;
  delete Arm_reflection_;
  delete Hat::default_instance_;
  delete Hat_reflection_;
  delete HMI::default_instance_;
  delete HMI_reflection_;
  delete ProcedureCmd::default_instance_;
  delete ProcedureCmd_reflection_;
  delete ProcedureStatus::default_instance_;
  delete ProcedureStatus_reflection_;
  delete HexaPos::default_instance_;
  delete HexaPos_reflection_;
  delete PlayerPos::default_instance_;
  delete PlayerPos_reflection_;
  delete Message::default_instance_;
  delete Message_default_oneof_instance_;
  delete Message_reflection_;
}

void protobuf_AddDesc_messages_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_messages_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\016messages.proto\022\tprotoduck\"*\n\003Pos\022\t\n\001x\030"
    "\001 \001(\002\022\t\n\001y\030\002 \001(\002\022\r\n\005theta\030\003 \001(\002\"/\n\005Speed"
    "\022\n\n\002vx\030\001 \001(\002\022\n\n\002vy\030\002 \001(\002\022\016\n\006vtheta\030\003 \001(\002"
    "\"1\n\013MotorsSpeed\022\n\n\002v1\030\001 \001(\002\022\n\n\002v2\030\002 \001(\002\022"
    "\n\n\002v3\030\003 \001(\002\"5\n\tMotorsCmd\022\014\n\004cmd1\030\001 \001(\002\022\014"
    "\n\004cmd2\030\002 \001(\002\022\014\n\004cmd3\030\003 \001(\002\"U\n\010MotorPid\022\020"
    "\n\010motor_no\030\001 \001(\r\022\023\n\013feedforward\030\002 \001(\002\022\n\n"
    "\002kp\030\003 \001(\002\022\n\n\002ki\030\004 \001(\002\022\n\n\002kd\030\005 \001(\002\"\026\n\003Bat"
    "\022\017\n\007voltage\030\001 \001(\002\"\200\001\n\003Arm\022 \n\006arm_id\030\001 \001("
    "\0162\020.protoduck.ArmID\022\014\n\004traZ\030\002 \001(\002\022\014\n\004rot"
    "Z\030\003 \001(\002\022\014\n\004rotY\030\004 \001(\002\022\014\n\004pump\030\005 \001(\010\022\r\n\005v"
    "alve\030\006 \001(\010\022\020\n\010pressure\030\007 \001(\002\"D\n\003Hat\022\016\n\006h"
    "eight\030\001 \001(\002\022\014\n\004pump\030\002 \001(\010\022\r\n\005valve\030\003 \001(\010"
    "\022\020\n\010pressure\030\004 \001(\002\"W\n\003HMI\022\r\n\005color\030\001 \001(\010"
    "\022\017\n\007tirette\030\002 \001(\010\022\016\n\006bouton\030\003 \001(\010\022\013\n\003led"
    "\030\004 \001(\r\022\023\n\013hmi_display\030\005 \001(\r\"\316\001\n\014Procedur"
    "eCmd\022 \n\006arm_id\030\001 \001(\0162\020.protoduck.ArmID\0224"
    "\n\tprocedure\030\002 \001(\0162!.protoduck.ProcedureC"
    "md.Procedure\022\r\n\005param\030\003 \001(\r\"W\n\tProcedure"
    "\022\010\n\004HOME\020\000\022\020\n\014PUT_ON_STACK\020\001\022\031\n\025TURN_AND"
    "_PUT_ON_STACK\020\002\022\023\n\017TAKE_FROM_STACK\020\003\"\242\001\n"
    "\017ProcedureStatus\0221\n\006status\030\001 \001(\0162!.proto"
    "duck.ProcedureStatus.Status\"\\\n\006Status\022\013\n"
    "\007SUCCESS\020\000\022\013\n\007RUNNING\020\001\022\013\n\007FAILURE\020\002\022\030\n\024"
    "POSITION_UNREACHABLE\020\003\022\021\n\rUNABLE_VACUUM\020"
    "\004\"\205\001\n\007HexaPos\022)\n\004type\030\001 \001(\0162\033.protoduck."
    "HexaPos.HexaType\022\033\n\003pos\030\002 \001(\0132\016.protoduc"
    "k.Pos\"2\n\010HexaType\022\010\n\004ROCK\020\000\022\007\n\003RED\020\001\022\t\n\005"
    "GREEN\020\002\022\010\n\004BLUE\020\003\"[\n\tPlayerPos\022\020\n\010aruco_"
    "id\030\001 \001(\r\022\033\n\003pos\030\002 \001(\0132\016.protoduck.Pos\022\037\n"
    "\005speed\030\003 \001(\0132\020.protoduck.Speed\"\311\005\n\007Messa"
    "ge\022(\n\006source\030\001 \001(\0162\030.protoduck.Message.A"
    "gent\022,\n\010msg_type\030\003 \001(\0162\032.protoduck.Messa"
    "ge.MsgType\022\035\n\003pos\030\004 \001(\0132\016.protoduck.PosH"
    "\000\022!\n\005speed\030\005 \001(\0132\020.protoduck.SpeedH\000\022.\n\014"
    "motors_speed\030\006 \001(\0132\026.protoduck.MotorsSpe"
    "edH\000\022*\n\nmotors_cmd\030\007 \001(\0132\024.protoduck.Mot"
    "orsCmdH\000\022(\n\tmotor_pid\030\010 \001(\0132\023.protoduck."
    "MotorPidH\000\022\035\n\003bat\030\t \001(\0132\016.protoduck.BatH"
    "\000\022\035\n\003arm\030\n \001(\0132\016.protoduck.ArmH\000\022\035\n\003hat\030"
    "\013 \001(\0132\016.protoduck.HatH\000\022\035\n\003hmi\030\014 \001(\0132\016.p"
    "rotoduck.HMIH\000\0220\n\rprocedure_cmd\030\r \001(\0132\027."
    "protoduck.ProcedureCmdH\000\0226\n\020procedure_st"
    "atus\030\016 \001(\0132\032.protoduck.ProcedureStatusH\000"
    "\022&\n\010hexa_pos\030\017 \001(\0132\022.protoduck.HexaPosH\000"
    "\022*\n\nplayer_pos\030\020 \001(\0132\024.protoduck.PlayerP"
    "osH\000\"\"\n\007MsgType\022\n\n\006STATUS\020\000\022\013\n\007COMMAND\020\001"
    "\"7\n\005Agent\022\010\n\004DIFF\020\000\022\010\n\004HOLO\020\001\022\t\n\005RASPI\020\002"
    "\022\007\n\003MAT\020\003\022\006\n\002PC\020\004B\007\n\005inner*\033\n\005ArmID\022\010\n\004A"
    "RM1\020\000\022\010\n\004ARM2\020\001b\006proto3", 1983);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "messages.proto", &protobuf_RegisterTypes);
  Pos::default_instance_ = new Pos();
  Speed::default_instance_ = new Speed();
  MotorsSpeed::default_instance_ = new MotorsSpeed();
  MotorsCmd::default_instance_ = new MotorsCmd();
  MotorPid::default_instance_ = new MotorPid();
  Bat::default_instance_ = new Bat();
  Arm::default_instance_ = new Arm();
  Hat::default_instance_ = new Hat();
  HMI::default_instance_ = new HMI();
  ProcedureCmd::default_instance_ = new ProcedureCmd();
  ProcedureStatus::default_instance_ = new ProcedureStatus();
  HexaPos::default_instance_ = new HexaPos();
  PlayerPos::default_instance_ = new PlayerPos();
  Message::default_instance_ = new Message();
  Message_default_oneof_instance_ = new MessageOneofInstance();
  Pos::default_instance_->InitAsDefaultInstance();
  Speed::default_instance_->InitAsDefaultInstance();
  MotorsSpeed::default_instance_->InitAsDefaultInstance();
  MotorsCmd::default_instance_->InitAsDefaultInstance();
  MotorPid::default_instance_->InitAsDefaultInstance();
  Bat::default_instance_->InitAsDefaultInstance();
  Arm::default_instance_->InitAsDefaultInstance();
  Hat::default_instance_->InitAsDefaultInstance();
  HMI::default_instance_->InitAsDefaultInstance();
  ProcedureCmd::default_instance_->InitAsDefaultInstance();
  ProcedureStatus::default_instance_->InitAsDefaultInstance();
  HexaPos::default_instance_->InitAsDefaultInstance();
  PlayerPos::default_instance_->InitAsDefaultInstance();
  Message::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_messages_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_messages_2eproto {
  StaticDescriptorInitializer_messages_2eproto() {
    protobuf_AddDesc_messages_2eproto();
  }
} static_descriptor_initializer_messages_2eproto_;
const ::google::protobuf::EnumDescriptor* ArmID_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ArmID_descriptor_;
}
bool ArmID_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Pos::kXFieldNumber;
const int Pos::kYFieldNumber;
const int Pos::kThetaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Pos::Pos()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Pos)
}

void Pos::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Pos::Pos(const Pos& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Pos)
}

void Pos::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  x_ = 0;
  y_ = 0;
  theta_ = 0;
}

Pos::~Pos() {
  // @@protoc_insertion_point(destructor:protoduck.Pos)
  SharedDtor();
}

void Pos::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Pos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Pos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Pos_descriptor_;
}

const Pos& Pos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Pos* Pos::default_instance_ = NULL;

Pos* Pos::New(::google::protobuf::Arena* arena) const {
  Pos* n = new Pos;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Pos::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Pos)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Pos, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Pos*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(x_, theta_);

#undef ZR_HELPER_
#undef ZR_

}

bool Pos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Pos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_y;
        break;
      }

      // optional float y = 2;
      case 2: {
        if (tag == 21) {
         parse_y:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &y_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_theta;
        break;
      }

      // optional float theta = 3;
      case 3: {
        if (tag == 29) {
         parse_theta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &theta_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Pos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Pos)
  return false;
#undef DO_
}

void Pos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Pos)
  // optional float x = 1;
  if (this->x() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // optional float y = 2;
  if (this->y() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->y(), output);
  }

  // optional float theta = 3;
  if (this->theta() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->theta(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Pos)
}

::google::protobuf::uint8* Pos::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Pos)
  // optional float x = 1;
  if (this->x() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // optional float y = 2;
  if (this->y() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->y(), target);
  }

  // optional float theta = 3;
  if (this->theta() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->theta(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Pos)
  return target;
}

int Pos::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Pos)
  int total_size = 0;

  // optional float x = 1;
  if (this->x() != 0) {
    total_size += 1 + 4;
  }

  // optional float y = 2;
  if (this->y() != 0) {
    total_size += 1 + 4;
  }

  // optional float theta = 3;
  if (this->theta() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Pos::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Pos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Pos* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Pos>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Pos)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Pos)
    MergeFrom(*source);
  }
}

void Pos::MergeFrom(const Pos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Pos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.x() != 0) {
    set_x(from.x());
  }
  if (from.y() != 0) {
    set_y(from.y());
  }
  if (from.theta() != 0) {
    set_theta(from.theta());
  }
}

void Pos::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Pos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Pos::CopyFrom(const Pos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Pos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Pos::IsInitialized() const {

  return true;
}

void Pos::Swap(Pos* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Pos::InternalSwap(Pos* other) {
  std::swap(x_, other->x_);
  std::swap(y_, other->y_);
  std::swap(theta_, other->theta_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Pos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Pos_descriptor_;
  metadata.reflection = Pos_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Pos

// optional float x = 1;
void Pos::clear_x() {
  x_ = 0;
}
 float Pos::x() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.x)
  return x_;
}
 void Pos::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.x)
}

// optional float y = 2;
void Pos::clear_y() {
  y_ = 0;
}
 float Pos::y() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.y)
  return y_;
}
 void Pos::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.y)
}

// optional float theta = 3;
void Pos::clear_theta() {
  theta_ = 0;
}
 float Pos::theta() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.theta)
  return theta_;
}
 void Pos::set_theta(float value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.theta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Speed::kVxFieldNumber;
const int Speed::kVyFieldNumber;
const int Speed::kVthetaFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Speed::Speed()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Speed)
}

void Speed::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Speed::Speed(const Speed& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Speed)
}

void Speed::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  vx_ = 0;
  vy_ = 0;
  vtheta_ = 0;
}

Speed::~Speed() {
  // @@protoc_insertion_point(destructor:protoduck.Speed)
  SharedDtor();
}

void Speed::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Speed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Speed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Speed_descriptor_;
}

const Speed& Speed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Speed* Speed::default_instance_ = NULL;

Speed* Speed::New(::google::protobuf::Arena* arena) const {
  Speed* n = new Speed;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Speed::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Speed)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Speed, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Speed*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(vx_, vtheta_);

#undef ZR_HELPER_
#undef ZR_

}

bool Speed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Speed)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float vx = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vx_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_vy;
        break;
      }

      // optional float vy = 2;
      case 2: {
        if (tag == 21) {
         parse_vy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vy_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_vtheta;
        break;
      }

      // optional float vtheta = 3;
      case 3: {
        if (tag == 29) {
         parse_vtheta:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &vtheta_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Speed)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Speed)
  return false;
#undef DO_
}

void Speed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Speed)
  // optional float vx = 1;
  if (this->vx() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->vx(), output);
  }

  // optional float vy = 2;
  if (this->vy() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->vy(), output);
  }

  // optional float vtheta = 3;
  if (this->vtheta() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->vtheta(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Speed)
}

::google::protobuf::uint8* Speed::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Speed)
  // optional float vx = 1;
  if (this->vx() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->vx(), target);
  }

  // optional float vy = 2;
  if (this->vy() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->vy(), target);
  }

  // optional float vtheta = 3;
  if (this->vtheta() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->vtheta(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Speed)
  return target;
}

int Speed::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Speed)
  int total_size = 0;

  // optional float vx = 1;
  if (this->vx() != 0) {
    total_size += 1 + 4;
  }

  // optional float vy = 2;
  if (this->vy() != 0) {
    total_size += 1 + 4;
  }

  // optional float vtheta = 3;
  if (this->vtheta() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Speed::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Speed)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Speed* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Speed>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Speed)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Speed)
    MergeFrom(*source);
  }
}

void Speed::MergeFrom(const Speed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Speed)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.vx() != 0) {
    set_vx(from.vx());
  }
  if (from.vy() != 0) {
    set_vy(from.vy());
  }
  if (from.vtheta() != 0) {
    set_vtheta(from.vtheta());
  }
}

void Speed::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Speed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Speed::CopyFrom(const Speed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Speed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Speed::IsInitialized() const {

  return true;
}

void Speed::Swap(Speed* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Speed::InternalSwap(Speed* other) {
  std::swap(vx_, other->vx_);
  std::swap(vy_, other->vy_);
  std::swap(vtheta_, other->vtheta_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Speed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Speed_descriptor_;
  metadata.reflection = Speed_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Speed

// optional float vx = 1;
void Speed::clear_vx() {
  vx_ = 0;
}
 float Speed::vx() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vx)
  return vx_;
}
 void Speed::set_vx(float value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vx)
}

// optional float vy = 2;
void Speed::clear_vy() {
  vy_ = 0;
}
 float Speed::vy() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vy)
  return vy_;
}
 void Speed::set_vy(float value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vy)
}

// optional float vtheta = 3;
void Speed::clear_vtheta() {
  vtheta_ = 0;
}
 float Speed::vtheta() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vtheta)
  return vtheta_;
}
 void Speed::set_vtheta(float value) {
  
  vtheta_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vtheta)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MotorsSpeed::kV1FieldNumber;
const int MotorsSpeed::kV2FieldNumber;
const int MotorsSpeed::kV3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MotorsSpeed::MotorsSpeed()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.MotorsSpeed)
}

void MotorsSpeed::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

MotorsSpeed::MotorsSpeed(const MotorsSpeed& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.MotorsSpeed)
}

void MotorsSpeed::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  v1_ = 0;
  v2_ = 0;
  v3_ = 0;
}

MotorsSpeed::~MotorsSpeed() {
  // @@protoc_insertion_point(destructor:protoduck.MotorsSpeed)
  SharedDtor();
}

void MotorsSpeed::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MotorsSpeed::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MotorsSpeed::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MotorsSpeed_descriptor_;
}

const MotorsSpeed& MotorsSpeed::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

MotorsSpeed* MotorsSpeed::default_instance_ = NULL;

MotorsSpeed* MotorsSpeed::New(::google::protobuf::Arena* arena) const {
  MotorsSpeed* n = new MotorsSpeed;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MotorsSpeed::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.MotorsSpeed)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MotorsSpeed, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MotorsSpeed*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(v1_, v3_);

#undef ZR_HELPER_
#undef ZR_

}

bool MotorsSpeed::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.MotorsSpeed)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float v1 = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v1_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_v2;
        break;
      }

      // optional float v2 = 2;
      case 2: {
        if (tag == 21) {
         parse_v2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v2_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_v3;
        break;
      }

      // optional float v3 = 3;
      case 3: {
        if (tag == 29) {
         parse_v3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &v3_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.MotorsSpeed)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.MotorsSpeed)
  return false;
#undef DO_
}

void MotorsSpeed::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.MotorsSpeed)
  // optional float v1 = 1;
  if (this->v1() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->v1(), output);
  }

  // optional float v2 = 2;
  if (this->v2() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->v2(), output);
  }

  // optional float v3 = 3;
  if (this->v3() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->v3(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.MotorsSpeed)
}

::google::protobuf::uint8* MotorsSpeed::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.MotorsSpeed)
  // optional float v1 = 1;
  if (this->v1() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->v1(), target);
  }

  // optional float v2 = 2;
  if (this->v2() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->v2(), target);
  }

  // optional float v3 = 3;
  if (this->v3() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->v3(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.MotorsSpeed)
  return target;
}

int MotorsSpeed::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.MotorsSpeed)
  int total_size = 0;

  // optional float v1 = 1;
  if (this->v1() != 0) {
    total_size += 1 + 4;
  }

  // optional float v2 = 2;
  if (this->v2() != 0) {
    total_size += 1 + 4;
  }

  // optional float v3 = 3;
  if (this->v3() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MotorsSpeed::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.MotorsSpeed)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MotorsSpeed* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MotorsSpeed>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.MotorsSpeed)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.MotorsSpeed)
    MergeFrom(*source);
  }
}

void MotorsSpeed::MergeFrom(const MotorsSpeed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.MotorsSpeed)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.v1() != 0) {
    set_v1(from.v1());
  }
  if (from.v2() != 0) {
    set_v2(from.v2());
  }
  if (from.v3() != 0) {
    set_v3(from.v3());
  }
}

void MotorsSpeed::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.MotorsSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotorsSpeed::CopyFrom(const MotorsSpeed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.MotorsSpeed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorsSpeed::IsInitialized() const {

  return true;
}

void MotorsSpeed::Swap(MotorsSpeed* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MotorsSpeed::InternalSwap(MotorsSpeed* other) {
  std::swap(v1_, other->v1_);
  std::swap(v2_, other->v2_);
  std::swap(v3_, other->v3_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MotorsSpeed::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MotorsSpeed_descriptor_;
  metadata.reflection = MotorsSpeed_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MotorsSpeed

// optional float v1 = 1;
void MotorsSpeed::clear_v1() {
  v1_ = 0;
}
 float MotorsSpeed::v1() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v1)
  return v1_;
}
 void MotorsSpeed::set_v1(float value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v1)
}

// optional float v2 = 2;
void MotorsSpeed::clear_v2() {
  v2_ = 0;
}
 float MotorsSpeed::v2() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v2)
  return v2_;
}
 void MotorsSpeed::set_v2(float value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v2)
}

// optional float v3 = 3;
void MotorsSpeed::clear_v3() {
  v3_ = 0;
}
 float MotorsSpeed::v3() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v3)
  return v3_;
}
 void MotorsSpeed::set_v3(float value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v3)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MotorsCmd::kCmd1FieldNumber;
const int MotorsCmd::kCmd2FieldNumber;
const int MotorsCmd::kCmd3FieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MotorsCmd::MotorsCmd()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.MotorsCmd)
}

void MotorsCmd::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

MotorsCmd::MotorsCmd(const MotorsCmd& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.MotorsCmd)
}

void MotorsCmd::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  cmd1_ = 0;
  cmd2_ = 0;
  cmd3_ = 0;
}

MotorsCmd::~MotorsCmd() {
  // @@protoc_insertion_point(destructor:protoduck.MotorsCmd)
  SharedDtor();
}

void MotorsCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MotorsCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MotorsCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MotorsCmd_descriptor_;
}

const MotorsCmd& MotorsCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

MotorsCmd* MotorsCmd::default_instance_ = NULL;

MotorsCmd* MotorsCmd::New(::google::protobuf::Arena* arena) const {
  MotorsCmd* n = new MotorsCmd;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MotorsCmd::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.MotorsCmd)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MotorsCmd, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MotorsCmd*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(cmd1_, cmd3_);

#undef ZR_HELPER_
#undef ZR_

}

bool MotorsCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.MotorsCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float cmd1 = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cmd1_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_cmd2;
        break;
      }

      // optional float cmd2 = 2;
      case 2: {
        if (tag == 21) {
         parse_cmd2:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cmd2_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_cmd3;
        break;
      }

      // optional float cmd3 = 3;
      case 3: {
        if (tag == 29) {
         parse_cmd3:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cmd3_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.MotorsCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.MotorsCmd)
  return false;
#undef DO_
}

void MotorsCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.MotorsCmd)
  // optional float cmd1 = 1;
  if (this->cmd1() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->cmd1(), output);
  }

  // optional float cmd2 = 2;
  if (this->cmd2() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->cmd2(), output);
  }

  // optional float cmd3 = 3;
  if (this->cmd3() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->cmd3(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.MotorsCmd)
}

::google::protobuf::uint8* MotorsCmd::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.MotorsCmd)
  // optional float cmd1 = 1;
  if (this->cmd1() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->cmd1(), target);
  }

  // optional float cmd2 = 2;
  if (this->cmd2() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->cmd2(), target);
  }

  // optional float cmd3 = 3;
  if (this->cmd3() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->cmd3(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.MotorsCmd)
  return target;
}

int MotorsCmd::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.MotorsCmd)
  int total_size = 0;

  // optional float cmd1 = 1;
  if (this->cmd1() != 0) {
    total_size += 1 + 4;
  }

  // optional float cmd2 = 2;
  if (this->cmd2() != 0) {
    total_size += 1 + 4;
  }

  // optional float cmd3 = 3;
  if (this->cmd3() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MotorsCmd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.MotorsCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MotorsCmd* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MotorsCmd>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.MotorsCmd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.MotorsCmd)
    MergeFrom(*source);
  }
}

void MotorsCmd::MergeFrom(const MotorsCmd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.MotorsCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.cmd1() != 0) {
    set_cmd1(from.cmd1());
  }
  if (from.cmd2() != 0) {
    set_cmd2(from.cmd2());
  }
  if (from.cmd3() != 0) {
    set_cmd3(from.cmd3());
  }
}

void MotorsCmd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.MotorsCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotorsCmd::CopyFrom(const MotorsCmd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.MotorsCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorsCmd::IsInitialized() const {

  return true;
}

void MotorsCmd::Swap(MotorsCmd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MotorsCmd::InternalSwap(MotorsCmd* other) {
  std::swap(cmd1_, other->cmd1_);
  std::swap(cmd2_, other->cmd2_);
  std::swap(cmd3_, other->cmd3_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MotorsCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MotorsCmd_descriptor_;
  metadata.reflection = MotorsCmd_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MotorsCmd

// optional float cmd1 = 1;
void MotorsCmd::clear_cmd1() {
  cmd1_ = 0;
}
 float MotorsCmd::cmd1() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd1)
  return cmd1_;
}
 void MotorsCmd::set_cmd1(float value) {
  
  cmd1_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd1)
}

// optional float cmd2 = 2;
void MotorsCmd::clear_cmd2() {
  cmd2_ = 0;
}
 float MotorsCmd::cmd2() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd2)
  return cmd2_;
}
 void MotorsCmd::set_cmd2(float value) {
  
  cmd2_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd2)
}

// optional float cmd3 = 3;
void MotorsCmd::clear_cmd3() {
  cmd3_ = 0;
}
 float MotorsCmd::cmd3() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd3)
  return cmd3_;
}
 void MotorsCmd::set_cmd3(float value) {
  
  cmd3_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd3)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MotorPid::kMotorNoFieldNumber;
const int MotorPid::kFeedforwardFieldNumber;
const int MotorPid::kKpFieldNumber;
const int MotorPid::kKiFieldNumber;
const int MotorPid::kKdFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MotorPid::MotorPid()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.MotorPid)
}

void MotorPid::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

MotorPid::MotorPid(const MotorPid& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.MotorPid)
}

void MotorPid::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  motor_no_ = 0u;
  feedforward_ = 0;
  kp_ = 0;
  ki_ = 0;
  kd_ = 0;
}

MotorPid::~MotorPid() {
  // @@protoc_insertion_point(destructor:protoduck.MotorPid)
  SharedDtor();
}

void MotorPid::SharedDtor() {
  if (this != default_instance_) {
  }
}

void MotorPid::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MotorPid::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MotorPid_descriptor_;
}

const MotorPid& MotorPid::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

MotorPid* MotorPid::default_instance_ = NULL;

MotorPid* MotorPid::New(::google::protobuf::Arena* arena) const {
  MotorPid* n = new MotorPid;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MotorPid::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.MotorPid)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(MotorPid, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<MotorPid*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(motor_no_, kd_);

#undef ZR_HELPER_
#undef ZR_

}

bool MotorPid::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.MotorPid)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 motor_no = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &motor_no_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_feedforward;
        break;
      }

      // optional float feedforward = 2;
      case 2: {
        if (tag == 21) {
         parse_feedforward:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &feedforward_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_kp;
        break;
      }

      // optional float kp = 3;
      case 3: {
        if (tag == 29) {
         parse_kp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kp_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_ki;
        break;
      }

      // optional float ki = 4;
      case 4: {
        if (tag == 37) {
         parse_ki:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ki_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_kd;
        break;
      }

      // optional float kd = 5;
      case 5: {
        if (tag == 45) {
         parse_kd:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &kd_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.MotorPid)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.MotorPid)
  return false;
#undef DO_
}

void MotorPid::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.MotorPid)
  // optional uint32 motor_no = 1;
  if (this->motor_no() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->motor_no(), output);
  }

  // optional float feedforward = 2;
  if (this->feedforward() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->feedforward(), output);
  }

  // optional float kp = 3;
  if (this->kp() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->kp(), output);
  }

  // optional float ki = 4;
  if (this->ki() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->ki(), output);
  }

  // optional float kd = 5;
  if (this->kd() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->kd(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.MotorPid)
}

::google::protobuf::uint8* MotorPid::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.MotorPid)
  // optional uint32 motor_no = 1;
  if (this->motor_no() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->motor_no(), target);
  }

  // optional float feedforward = 2;
  if (this->feedforward() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->feedforward(), target);
  }

  // optional float kp = 3;
  if (this->kp() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->kp(), target);
  }

  // optional float ki = 4;
  if (this->ki() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->ki(), target);
  }

  // optional float kd = 5;
  if (this->kd() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->kd(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.MotorPid)
  return target;
}

int MotorPid::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.MotorPid)
  int total_size = 0;

  // optional uint32 motor_no = 1;
  if (this->motor_no() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->motor_no());
  }

  // optional float feedforward = 2;
  if (this->feedforward() != 0) {
    total_size += 1 + 4;
  }

  // optional float kp = 3;
  if (this->kp() != 0) {
    total_size += 1 + 4;
  }

  // optional float ki = 4;
  if (this->ki() != 0) {
    total_size += 1 + 4;
  }

  // optional float kd = 5;
  if (this->kd() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MotorPid::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.MotorPid)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MotorPid* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MotorPid>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.MotorPid)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.MotorPid)
    MergeFrom(*source);
  }
}

void MotorPid::MergeFrom(const MotorPid& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.MotorPid)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.motor_no() != 0) {
    set_motor_no(from.motor_no());
  }
  if (from.feedforward() != 0) {
    set_feedforward(from.feedforward());
  }
  if (from.kp() != 0) {
    set_kp(from.kp());
  }
  if (from.ki() != 0) {
    set_ki(from.ki());
  }
  if (from.kd() != 0) {
    set_kd(from.kd());
  }
}

void MotorPid::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.MotorPid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MotorPid::CopyFrom(const MotorPid& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.MotorPid)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MotorPid::IsInitialized() const {

  return true;
}

void MotorPid::Swap(MotorPid* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MotorPid::InternalSwap(MotorPid* other) {
  std::swap(motor_no_, other->motor_no_);
  std::swap(feedforward_, other->feedforward_);
  std::swap(kp_, other->kp_);
  std::swap(ki_, other->ki_);
  std::swap(kd_, other->kd_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MotorPid::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MotorPid_descriptor_;
  metadata.reflection = MotorPid_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MotorPid

// optional uint32 motor_no = 1;
void MotorPid::clear_motor_no() {
  motor_no_ = 0u;
}
 ::google::protobuf::uint32 MotorPid::motor_no() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.motor_no)
  return motor_no_;
}
 void MotorPid::set_motor_no(::google::protobuf::uint32 value) {
  
  motor_no_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.motor_no)
}

// optional float feedforward = 2;
void MotorPid::clear_feedforward() {
  feedforward_ = 0;
}
 float MotorPid::feedforward() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.feedforward)
  return feedforward_;
}
 void MotorPid::set_feedforward(float value) {
  
  feedforward_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.feedforward)
}

// optional float kp = 3;
void MotorPid::clear_kp() {
  kp_ = 0;
}
 float MotorPid::kp() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.kp)
  return kp_;
}
 void MotorPid::set_kp(float value) {
  
  kp_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.kp)
}

// optional float ki = 4;
void MotorPid::clear_ki() {
  ki_ = 0;
}
 float MotorPid::ki() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.ki)
  return ki_;
}
 void MotorPid::set_ki(float value) {
  
  ki_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.ki)
}

// optional float kd = 5;
void MotorPid::clear_kd() {
  kd_ = 0;
}
 float MotorPid::kd() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.kd)
  return kd_;
}
 void MotorPid::set_kd(float value) {
  
  kd_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.kd)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Bat::kVoltageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Bat::Bat()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Bat)
}

void Bat::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Bat::Bat(const Bat& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Bat)
}

void Bat::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  voltage_ = 0;
}

Bat::~Bat() {
  // @@protoc_insertion_point(destructor:protoduck.Bat)
  SharedDtor();
}

void Bat::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Bat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Bat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Bat_descriptor_;
}

const Bat& Bat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Bat* Bat::default_instance_ = NULL;

Bat* Bat::New(::google::protobuf::Arena* arena) const {
  Bat* n = new Bat;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Bat::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Bat)
  voltage_ = 0;
}

bool Bat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Bat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float voltage = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &voltage_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Bat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Bat)
  return false;
#undef DO_
}

void Bat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Bat)
  // optional float voltage = 1;
  if (this->voltage() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->voltage(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Bat)
}

::google::protobuf::uint8* Bat::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Bat)
  // optional float voltage = 1;
  if (this->voltage() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->voltage(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Bat)
  return target;
}

int Bat::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Bat)
  int total_size = 0;

  // optional float voltage = 1;
  if (this->voltage() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Bat::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Bat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Bat* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Bat>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Bat)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Bat)
    MergeFrom(*source);
  }
}

void Bat::MergeFrom(const Bat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Bat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.voltage() != 0) {
    set_voltage(from.voltage());
  }
}

void Bat::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Bat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Bat::CopyFrom(const Bat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Bat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Bat::IsInitialized() const {

  return true;
}

void Bat::Swap(Bat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Bat::InternalSwap(Bat* other) {
  std::swap(voltage_, other->voltage_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Bat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Bat_descriptor_;
  metadata.reflection = Bat_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Bat

// optional float voltage = 1;
void Bat::clear_voltage() {
  voltage_ = 0;
}
 float Bat::voltage() const {
  // @@protoc_insertion_point(field_get:protoduck.Bat.voltage)
  return voltage_;
}
 void Bat::set_voltage(float value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Bat.voltage)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Arm::kArmIdFieldNumber;
const int Arm::kTraZFieldNumber;
const int Arm::kRotZFieldNumber;
const int Arm::kRotYFieldNumber;
const int Arm::kPumpFieldNumber;
const int Arm::kValveFieldNumber;
const int Arm::kPressureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Arm::Arm()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Arm)
}

void Arm::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Arm::Arm(const Arm& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Arm)
}

void Arm::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  arm_id_ = 0;
  traz_ = 0;
  rotz_ = 0;
  roty_ = 0;
  pump_ = false;
  valve_ = false;
  pressure_ = 0;
}

Arm::~Arm() {
  // @@protoc_insertion_point(destructor:protoduck.Arm)
  SharedDtor();
}

void Arm::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Arm::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Arm::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Arm_descriptor_;
}

const Arm& Arm::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Arm* Arm::default_instance_ = NULL;

Arm* Arm::New(::google::protobuf::Arena* arena) const {
  Arm* n = new Arm;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Arm::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Arm)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Arm, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Arm*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(arm_id_, pressure_);

#undef ZR_HELPER_
#undef ZR_

}

bool Arm::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Arm)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protoduck.ArmID arm_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_arm_id(static_cast< ::protoduck::ArmID >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_traZ;
        break;
      }

      // optional float traZ = 2;
      case 2: {
        if (tag == 21) {
         parse_traZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &traz_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_rotZ;
        break;
      }

      // optional float rotZ = 3;
      case 3: {
        if (tag == 29) {
         parse_rotZ:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &rotz_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_rotY;
        break;
      }

      // optional float rotY = 4;
      case 4: {
        if (tag == 37) {
         parse_rotY:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &roty_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_pump;
        break;
      }

      // optional bool pump = 5;
      case 5: {
        if (tag == 40) {
         parse_pump:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pump_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_valve;
        break;
      }

      // optional bool valve = 6;
      case 6: {
        if (tag == 48) {
         parse_valve:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valve_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_pressure;
        break;
      }

      // optional float pressure = 7;
      case 7: {
        if (tag == 61) {
         parse_pressure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pressure_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Arm)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Arm)
  return false;
#undef DO_
}

void Arm::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Arm)
  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->arm_id(), output);
  }

  // optional float traZ = 2;
  if (this->traz() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->traz(), output);
  }

  // optional float rotZ = 3;
  if (this->rotz() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->rotz(), output);
  }

  // optional float rotY = 4;
  if (this->roty() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->roty(), output);
  }

  // optional bool pump = 5;
  if (this->pump() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(5, this->pump(), output);
  }

  // optional bool valve = 6;
  if (this->valve() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->valve(), output);
  }

  // optional float pressure = 7;
  if (this->pressure() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->pressure(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Arm)
}

::google::protobuf::uint8* Arm::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Arm)
  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->arm_id(), target);
  }

  // optional float traZ = 2;
  if (this->traz() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->traz(), target);
  }

  // optional float rotZ = 3;
  if (this->rotz() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->rotz(), target);
  }

  // optional float rotY = 4;
  if (this->roty() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->roty(), target);
  }

  // optional bool pump = 5;
  if (this->pump() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(5, this->pump(), target);
  }

  // optional bool valve = 6;
  if (this->valve() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->valve(), target);
  }

  // optional float pressure = 7;
  if (this->pressure() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->pressure(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Arm)
  return target;
}

int Arm::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Arm)
  int total_size = 0;

  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->arm_id());
  }

  // optional float traZ = 2;
  if (this->traz() != 0) {
    total_size += 1 + 4;
  }

  // optional float rotZ = 3;
  if (this->rotz() != 0) {
    total_size += 1 + 4;
  }

  // optional float rotY = 4;
  if (this->roty() != 0) {
    total_size += 1 + 4;
  }

  // optional bool pump = 5;
  if (this->pump() != 0) {
    total_size += 1 + 1;
  }

  // optional bool valve = 6;
  if (this->valve() != 0) {
    total_size += 1 + 1;
  }

  // optional float pressure = 7;
  if (this->pressure() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Arm::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Arm)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Arm* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Arm>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Arm)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Arm)
    MergeFrom(*source);
  }
}

void Arm::MergeFrom(const Arm& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Arm)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.arm_id() != 0) {
    set_arm_id(from.arm_id());
  }
  if (from.traz() != 0) {
    set_traz(from.traz());
  }
  if (from.rotz() != 0) {
    set_rotz(from.rotz());
  }
  if (from.roty() != 0) {
    set_roty(from.roty());
  }
  if (from.pump() != 0) {
    set_pump(from.pump());
  }
  if (from.valve() != 0) {
    set_valve(from.valve());
  }
  if (from.pressure() != 0) {
    set_pressure(from.pressure());
  }
}

void Arm::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Arm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Arm::CopyFrom(const Arm& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Arm)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Arm::IsInitialized() const {

  return true;
}

void Arm::Swap(Arm* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Arm::InternalSwap(Arm* other) {
  std::swap(arm_id_, other->arm_id_);
  std::swap(traz_, other->traz_);
  std::swap(rotz_, other->rotz_);
  std::swap(roty_, other->roty_);
  std::swap(pump_, other->pump_);
  std::swap(valve_, other->valve_);
  std::swap(pressure_, other->pressure_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Arm::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Arm_descriptor_;
  metadata.reflection = Arm_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Arm

// optional .protoduck.ArmID arm_id = 1;
void Arm::clear_arm_id() {
  arm_id_ = 0;
}
 ::protoduck::ArmID Arm::arm_id() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.arm_id)
  return static_cast< ::protoduck::ArmID >(arm_id_);
}
 void Arm::set_arm_id(::protoduck::ArmID value) {
  
  arm_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.arm_id)
}

// optional float traZ = 2;
void Arm::clear_traz() {
  traz_ = 0;
}
 float Arm::traz() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.traZ)
  return traz_;
}
 void Arm::set_traz(float value) {
  
  traz_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.traZ)
}

// optional float rotZ = 3;
void Arm::clear_rotz() {
  rotz_ = 0;
}
 float Arm::rotz() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.rotZ)
  return rotz_;
}
 void Arm::set_rotz(float value) {
  
  rotz_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.rotZ)
}

// optional float rotY = 4;
void Arm::clear_roty() {
  roty_ = 0;
}
 float Arm::roty() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.rotY)
  return roty_;
}
 void Arm::set_roty(float value) {
  
  roty_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.rotY)
}

// optional bool pump = 5;
void Arm::clear_pump() {
  pump_ = false;
}
 bool Arm::pump() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.pump)
  return pump_;
}
 void Arm::set_pump(bool value) {
  
  pump_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.pump)
}

// optional bool valve = 6;
void Arm::clear_valve() {
  valve_ = false;
}
 bool Arm::valve() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.valve)
  return valve_;
}
 void Arm::set_valve(bool value) {
  
  valve_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.valve)
}

// optional float pressure = 7;
void Arm::clear_pressure() {
  pressure_ = 0;
}
 float Arm::pressure() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.pressure)
  return pressure_;
}
 void Arm::set_pressure(float value) {
  
  pressure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.pressure)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Hat::kHeightFieldNumber;
const int Hat::kPumpFieldNumber;
const int Hat::kValveFieldNumber;
const int Hat::kPressureFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Hat::Hat()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Hat)
}

void Hat::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Hat::Hat(const Hat& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Hat)
}

void Hat::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  height_ = 0;
  pump_ = false;
  valve_ = false;
  pressure_ = 0;
}

Hat::~Hat() {
  // @@protoc_insertion_point(destructor:protoduck.Hat)
  SharedDtor();
}

void Hat::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Hat::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Hat::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Hat_descriptor_;
}

const Hat& Hat::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Hat* Hat::default_instance_ = NULL;

Hat* Hat::New(::google::protobuf::Arena* arena) const {
  Hat* n = new Hat;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Hat::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Hat)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Hat, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Hat*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(height_, pressure_);

#undef ZR_HELPER_
#undef ZR_

}

bool Hat::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Hat)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float height = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &height_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_pump;
        break;
      }

      // optional bool pump = 2;
      case 2: {
        if (tag == 16) {
         parse_pump:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &pump_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_valve;
        break;
      }

      // optional bool valve = 3;
      case 3: {
        if (tag == 24) {
         parse_valve:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &valve_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_pressure;
        break;
      }

      // optional float pressure = 4;
      case 4: {
        if (tag == 37) {
         parse_pressure:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &pressure_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Hat)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Hat)
  return false;
#undef DO_
}

void Hat::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Hat)
  // optional float height = 1;
  if (this->height() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->height(), output);
  }

  // optional bool pump = 2;
  if (this->pump() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->pump(), output);
  }

  // optional bool valve = 3;
  if (this->valve() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->valve(), output);
  }

  // optional float pressure = 4;
  if (this->pressure() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->pressure(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Hat)
}

::google::protobuf::uint8* Hat::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Hat)
  // optional float height = 1;
  if (this->height() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->height(), target);
  }

  // optional bool pump = 2;
  if (this->pump() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->pump(), target);
  }

  // optional bool valve = 3;
  if (this->valve() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->valve(), target);
  }

  // optional float pressure = 4;
  if (this->pressure() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->pressure(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Hat)
  return target;
}

int Hat::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Hat)
  int total_size = 0;

  // optional float height = 1;
  if (this->height() != 0) {
    total_size += 1 + 4;
  }

  // optional bool pump = 2;
  if (this->pump() != 0) {
    total_size += 1 + 1;
  }

  // optional bool valve = 3;
  if (this->valve() != 0) {
    total_size += 1 + 1;
  }

  // optional float pressure = 4;
  if (this->pressure() != 0) {
    total_size += 1 + 4;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Hat::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Hat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Hat* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Hat>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Hat)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Hat)
    MergeFrom(*source);
  }
}

void Hat::MergeFrom(const Hat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Hat)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.height() != 0) {
    set_height(from.height());
  }
  if (from.pump() != 0) {
    set_pump(from.pump());
  }
  if (from.valve() != 0) {
    set_valve(from.valve());
  }
  if (from.pressure() != 0) {
    set_pressure(from.pressure());
  }
}

void Hat::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Hat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Hat::CopyFrom(const Hat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Hat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Hat::IsInitialized() const {

  return true;
}

void Hat::Swap(Hat* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Hat::InternalSwap(Hat* other) {
  std::swap(height_, other->height_);
  std::swap(pump_, other->pump_);
  std::swap(valve_, other->valve_);
  std::swap(pressure_, other->pressure_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Hat::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Hat_descriptor_;
  metadata.reflection = Hat_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Hat

// optional float height = 1;
void Hat::clear_height() {
  height_ = 0;
}
 float Hat::height() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.height)
  return height_;
}
 void Hat::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.height)
}

// optional bool pump = 2;
void Hat::clear_pump() {
  pump_ = false;
}
 bool Hat::pump() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.pump)
  return pump_;
}
 void Hat::set_pump(bool value) {
  
  pump_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.pump)
}

// optional bool valve = 3;
void Hat::clear_valve() {
  valve_ = false;
}
 bool Hat::valve() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.valve)
  return valve_;
}
 void Hat::set_valve(bool value) {
  
  valve_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.valve)
}

// optional float pressure = 4;
void Hat::clear_pressure() {
  pressure_ = 0;
}
 float Hat::pressure() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.pressure)
  return pressure_;
}
 void Hat::set_pressure(float value) {
  
  pressure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.pressure)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HMI::kColorFieldNumber;
const int HMI::kTiretteFieldNumber;
const int HMI::kBoutonFieldNumber;
const int HMI::kLedFieldNumber;
const int HMI::kHmiDisplayFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HMI::HMI()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.HMI)
}

void HMI::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

HMI::HMI(const HMI& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.HMI)
}

void HMI::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  color_ = false;
  tirette_ = false;
  bouton_ = false;
  led_ = 0u;
  hmi_display_ = 0u;
}

HMI::~HMI() {
  // @@protoc_insertion_point(destructor:protoduck.HMI)
  SharedDtor();
}

void HMI::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HMI::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HMI::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HMI_descriptor_;
}

const HMI& HMI::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

HMI* HMI::default_instance_ = NULL;

HMI* HMI::New(::google::protobuf::Arena* arena) const {
  HMI* n = new HMI;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HMI::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.HMI)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(HMI, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<HMI*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(color_, hmi_display_);

#undef ZR_HELPER_
#undef ZR_

}

bool HMI::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.HMI)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool color = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &color_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_tirette;
        break;
      }

      // optional bool tirette = 2;
      case 2: {
        if (tag == 16) {
         parse_tirette:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &tirette_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_bouton;
        break;
      }

      // optional bool bouton = 3;
      case 3: {
        if (tag == 24) {
         parse_bouton:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &bouton_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_led;
        break;
      }

      // optional uint32 led = 4;
      case 4: {
        if (tag == 32) {
         parse_led:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &led_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_hmi_display;
        break;
      }

      // optional uint32 hmi_display = 5;
      case 5: {
        if (tag == 40) {
         parse_hmi_display:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &hmi_display_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.HMI)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.HMI)
  return false;
#undef DO_
}

void HMI::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.HMI)
  // optional bool color = 1;
  if (this->color() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->color(), output);
  }

  // optional bool tirette = 2;
  if (this->tirette() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->tirette(), output);
  }

  // optional bool bouton = 3;
  if (this->bouton() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->bouton(), output);
  }

  // optional uint32 led = 4;
  if (this->led() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(4, this->led(), output);
  }

  // optional uint32 hmi_display = 5;
  if (this->hmi_display() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->hmi_display(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.HMI)
}

::google::protobuf::uint8* HMI::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.HMI)
  // optional bool color = 1;
  if (this->color() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->color(), target);
  }

  // optional bool tirette = 2;
  if (this->tirette() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->tirette(), target);
  }

  // optional bool bouton = 3;
  if (this->bouton() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->bouton(), target);
  }

  // optional uint32 led = 4;
  if (this->led() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(4, this->led(), target);
  }

  // optional uint32 hmi_display = 5;
  if (this->hmi_display() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->hmi_display(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.HMI)
  return target;
}

int HMI::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.HMI)
  int total_size = 0;

  // optional bool color = 1;
  if (this->color() != 0) {
    total_size += 1 + 1;
  }

  // optional bool tirette = 2;
  if (this->tirette() != 0) {
    total_size += 1 + 1;
  }

  // optional bool bouton = 3;
  if (this->bouton() != 0) {
    total_size += 1 + 1;
  }

  // optional uint32 led = 4;
  if (this->led() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->led());
  }

  // optional uint32 hmi_display = 5;
  if (this->hmi_display() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->hmi_display());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HMI::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.HMI)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HMI* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HMI>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.HMI)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.HMI)
    MergeFrom(*source);
  }
}

void HMI::MergeFrom(const HMI& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.HMI)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.color() != 0) {
    set_color(from.color());
  }
  if (from.tirette() != 0) {
    set_tirette(from.tirette());
  }
  if (from.bouton() != 0) {
    set_bouton(from.bouton());
  }
  if (from.led() != 0) {
    set_led(from.led());
  }
  if (from.hmi_display() != 0) {
    set_hmi_display(from.hmi_display());
  }
}

void HMI::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.HMI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HMI::CopyFrom(const HMI& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.HMI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HMI::IsInitialized() const {

  return true;
}

void HMI::Swap(HMI* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HMI::InternalSwap(HMI* other) {
  std::swap(color_, other->color_);
  std::swap(tirette_, other->tirette_);
  std::swap(bouton_, other->bouton_);
  std::swap(led_, other->led_);
  std::swap(hmi_display_, other->hmi_display_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HMI::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HMI_descriptor_;
  metadata.reflection = HMI_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HMI

// optional bool color = 1;
void HMI::clear_color() {
  color_ = false;
}
 bool HMI::color() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.color)
  return color_;
}
 void HMI::set_color(bool value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.color)
}

// optional bool tirette = 2;
void HMI::clear_tirette() {
  tirette_ = false;
}
 bool HMI::tirette() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.tirette)
  return tirette_;
}
 void HMI::set_tirette(bool value) {
  
  tirette_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.tirette)
}

// optional bool bouton = 3;
void HMI::clear_bouton() {
  bouton_ = false;
}
 bool HMI::bouton() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.bouton)
  return bouton_;
}
 void HMI::set_bouton(bool value) {
  
  bouton_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.bouton)
}

// optional uint32 led = 4;
void HMI::clear_led() {
  led_ = 0u;
}
 ::google::protobuf::uint32 HMI::led() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.led)
  return led_;
}
 void HMI::set_led(::google::protobuf::uint32 value) {
  
  led_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.led)
}

// optional uint32 hmi_display = 5;
void HMI::clear_hmi_display() {
  hmi_display_ = 0u;
}
 ::google::protobuf::uint32 HMI::hmi_display() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.hmi_display)
  return hmi_display_;
}
 void HMI::set_hmi_display(::google::protobuf::uint32 value) {
  
  hmi_display_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.hmi_display)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ProcedureCmd_Procedure_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureCmd_Procedure_descriptor_;
}
bool ProcedureCmd_Procedure_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ProcedureCmd_Procedure ProcedureCmd::HOME;
const ProcedureCmd_Procedure ProcedureCmd::PUT_ON_STACK;
const ProcedureCmd_Procedure ProcedureCmd::TURN_AND_PUT_ON_STACK;
const ProcedureCmd_Procedure ProcedureCmd::TAKE_FROM_STACK;
const ProcedureCmd_Procedure ProcedureCmd::Procedure_MIN;
const ProcedureCmd_Procedure ProcedureCmd::Procedure_MAX;
const int ProcedureCmd::Procedure_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProcedureCmd::kArmIdFieldNumber;
const int ProcedureCmd::kProcedureFieldNumber;
const int ProcedureCmd::kParamFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProcedureCmd::ProcedureCmd()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.ProcedureCmd)
}

void ProcedureCmd::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ProcedureCmd::ProcedureCmd(const ProcedureCmd& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.ProcedureCmd)
}

void ProcedureCmd::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  arm_id_ = 0;
  procedure_ = 0;
  param_ = 0u;
}

ProcedureCmd::~ProcedureCmd() {
  // @@protoc_insertion_point(destructor:protoduck.ProcedureCmd)
  SharedDtor();
}

void ProcedureCmd::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureCmd::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureCmd::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureCmd_descriptor_;
}

const ProcedureCmd& ProcedureCmd::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProcedureCmd* ProcedureCmd::default_instance_ = NULL;

ProcedureCmd* ProcedureCmd::New(::google::protobuf::Arena* arena) const {
  ProcedureCmd* n = new ProcedureCmd;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProcedureCmd::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.ProcedureCmd)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ProcedureCmd, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ProcedureCmd*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(arm_id_, param_);

#undef ZR_HELPER_
#undef ZR_

}

bool ProcedureCmd::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.ProcedureCmd)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protoduck.ArmID arm_id = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_arm_id(static_cast< ::protoduck::ArmID >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_procedure;
        break;
      }

      // optional .protoduck.ProcedureCmd.Procedure procedure = 2;
      case 2: {
        if (tag == 16) {
         parse_procedure:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_procedure(static_cast< ::protoduck::ProcedureCmd_Procedure >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_param;
        break;
      }

      // optional uint32 param = 3;
      case 3: {
        if (tag == 24) {
         parse_param:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &param_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.ProcedureCmd)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.ProcedureCmd)
  return false;
#undef DO_
}

void ProcedureCmd::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.ProcedureCmd)
  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->arm_id(), output);
  }

  // optional .protoduck.ProcedureCmd.Procedure procedure = 2;
  if (this->procedure() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->procedure(), output);
  }

  // optional uint32 param = 3;
  if (this->param() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->param(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.ProcedureCmd)
}

::google::protobuf::uint8* ProcedureCmd::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.ProcedureCmd)
  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->arm_id(), target);
  }

  // optional .protoduck.ProcedureCmd.Procedure procedure = 2;
  if (this->procedure() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->procedure(), target);
  }

  // optional uint32 param = 3;
  if (this->param() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->param(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.ProcedureCmd)
  return target;
}

int ProcedureCmd::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.ProcedureCmd)
  int total_size = 0;

  // optional .protoduck.ArmID arm_id = 1;
  if (this->arm_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->arm_id());
  }

  // optional .protoduck.ProcedureCmd.Procedure procedure = 2;
  if (this->procedure() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->procedure());
  }

  // optional uint32 param = 3;
  if (this->param() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->param());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureCmd::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.ProcedureCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ProcedureCmd* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ProcedureCmd>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.ProcedureCmd)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.ProcedureCmd)
    MergeFrom(*source);
  }
}

void ProcedureCmd::MergeFrom(const ProcedureCmd& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.ProcedureCmd)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.arm_id() != 0) {
    set_arm_id(from.arm_id());
  }
  if (from.procedure() != 0) {
    set_procedure(from.procedure());
  }
  if (from.param() != 0) {
    set_param(from.param());
  }
}

void ProcedureCmd::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.ProcedureCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureCmd::CopyFrom(const ProcedureCmd& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.ProcedureCmd)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureCmd::IsInitialized() const {

  return true;
}

void ProcedureCmd::Swap(ProcedureCmd* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProcedureCmd::InternalSwap(ProcedureCmd* other) {
  std::swap(arm_id_, other->arm_id_);
  std::swap(procedure_, other->procedure_);
  std::swap(param_, other->param_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ProcedureCmd::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureCmd_descriptor_;
  metadata.reflection = ProcedureCmd_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcedureCmd

// optional .protoduck.ArmID arm_id = 1;
void ProcedureCmd::clear_arm_id() {
  arm_id_ = 0;
}
 ::protoduck::ArmID ProcedureCmd::arm_id() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.arm_id)
  return static_cast< ::protoduck::ArmID >(arm_id_);
}
 void ProcedureCmd::set_arm_id(::protoduck::ArmID value) {
  
  arm_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.arm_id)
}

// optional .protoduck.ProcedureCmd.Procedure procedure = 2;
void ProcedureCmd::clear_procedure() {
  procedure_ = 0;
}
 ::protoduck::ProcedureCmd_Procedure ProcedureCmd::procedure() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.procedure)
  return static_cast< ::protoduck::ProcedureCmd_Procedure >(procedure_);
}
 void ProcedureCmd::set_procedure(::protoduck::ProcedureCmd_Procedure value) {
  
  procedure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.procedure)
}

// optional uint32 param = 3;
void ProcedureCmd::clear_param() {
  param_ = 0u;
}
 ::google::protobuf::uint32 ProcedureCmd::param() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.param)
  return param_;
}
 void ProcedureCmd::set_param(::google::protobuf::uint32 value) {
  
  param_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.param)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ProcedureStatus_Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureStatus_Status_descriptor_;
}
bool ProcedureStatus_Status_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ProcedureStatus_Status ProcedureStatus::SUCCESS;
const ProcedureStatus_Status ProcedureStatus::RUNNING;
const ProcedureStatus_Status ProcedureStatus::FAILURE;
const ProcedureStatus_Status ProcedureStatus::POSITION_UNREACHABLE;
const ProcedureStatus_Status ProcedureStatus::UNABLE_VACUUM;
const ProcedureStatus_Status ProcedureStatus::Status_MIN;
const ProcedureStatus_Status ProcedureStatus::Status_MAX;
const int ProcedureStatus::Status_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ProcedureStatus::kStatusFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ProcedureStatus::ProcedureStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.ProcedureStatus)
}

void ProcedureStatus::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ProcedureStatus::ProcedureStatus(const ProcedureStatus& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.ProcedureStatus)
}

void ProcedureStatus::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  status_ = 0;
}

ProcedureStatus::~ProcedureStatus() {
  // @@protoc_insertion_point(destructor:protoduck.ProcedureStatus)
  SharedDtor();
}

void ProcedureStatus::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ProcedureStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ProcedureStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ProcedureStatus_descriptor_;
}

const ProcedureStatus& ProcedureStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

ProcedureStatus* ProcedureStatus::default_instance_ = NULL;

ProcedureStatus* ProcedureStatus::New(::google::protobuf::Arena* arena) const {
  ProcedureStatus* n = new ProcedureStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ProcedureStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.ProcedureStatus)
  status_ = 0;
}

bool ProcedureStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.ProcedureStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protoduck.ProcedureStatus.Status status = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_status(static_cast< ::protoduck::ProcedureStatus_Status >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.ProcedureStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.ProcedureStatus)
  return false;
#undef DO_
}

void ProcedureStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.ProcedureStatus)
  // optional .protoduck.ProcedureStatus.Status status = 1;
  if (this->status() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->status(), output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.ProcedureStatus)
}

::google::protobuf::uint8* ProcedureStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.ProcedureStatus)
  // optional .protoduck.ProcedureStatus.Status status = 1;
  if (this->status() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->status(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.ProcedureStatus)
  return target;
}

int ProcedureStatus::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.ProcedureStatus)
  int total_size = 0;

  // optional .protoduck.ProcedureStatus.Status status = 1;
  if (this->status() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->status());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ProcedureStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.ProcedureStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ProcedureStatus* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ProcedureStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.ProcedureStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.ProcedureStatus)
    MergeFrom(*source);
  }
}

void ProcedureStatus::MergeFrom(const ProcedureStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.ProcedureStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.status() != 0) {
    set_status(from.status());
  }
}

void ProcedureStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.ProcedureStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ProcedureStatus::CopyFrom(const ProcedureStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.ProcedureStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProcedureStatus::IsInitialized() const {

  return true;
}

void ProcedureStatus::Swap(ProcedureStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ProcedureStatus::InternalSwap(ProcedureStatus* other) {
  std::swap(status_, other->status_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ProcedureStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ProcedureStatus_descriptor_;
  metadata.reflection = ProcedureStatus_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ProcedureStatus

// optional .protoduck.ProcedureStatus.Status status = 1;
void ProcedureStatus::clear_status() {
  status_ = 0;
}
 ::protoduck::ProcedureStatus_Status ProcedureStatus::status() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureStatus.status)
  return static_cast< ::protoduck::ProcedureStatus_Status >(status_);
}
 void ProcedureStatus::set_status(::protoduck::ProcedureStatus_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureStatus.status)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* HexaPos_HexaType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HexaPos_HexaType_descriptor_;
}
bool HexaPos_HexaType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const HexaPos_HexaType HexaPos::ROCK;
const HexaPos_HexaType HexaPos::RED;
const HexaPos_HexaType HexaPos::GREEN;
const HexaPos_HexaType HexaPos::BLUE;
const HexaPos_HexaType HexaPos::HexaType_MIN;
const HexaPos_HexaType HexaPos::HexaType_MAX;
const int HexaPos::HexaType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HexaPos::kTypeFieldNumber;
const int HexaPos::kPosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HexaPos::HexaPos()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.HexaPos)
}

void HexaPos::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  pos_ = const_cast< ::protoduck::Pos*>(&::protoduck::Pos::default_instance());
}

HexaPos::HexaPos(const HexaPos& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.HexaPos)
}

void HexaPos::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  type_ = 0;
  pos_ = NULL;
}

HexaPos::~HexaPos() {
  // @@protoc_insertion_point(destructor:protoduck.HexaPos)
  SharedDtor();
}

void HexaPos::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
  }
}

void HexaPos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HexaPos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HexaPos_descriptor_;
}

const HexaPos& HexaPos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

HexaPos* HexaPos::default_instance_ = NULL;

HexaPos* HexaPos::New(::google::protobuf::Arena* arena) const {
  HexaPos* n = new HexaPos;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HexaPos::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.HexaPos)
  type_ = 0;
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}

bool HexaPos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.HexaPos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protoduck.HexaPos.HexaType type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::protoduck::HexaPos_HexaType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pos;
        break;
      }

      // optional .protoduck.Pos pos = 2;
      case 2: {
        if (tag == 18) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.HexaPos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.HexaPos)
  return false;
#undef DO_
}

void HexaPos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.HexaPos)
  // optional .protoduck.HexaPos.HexaType type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pos_, output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.HexaPos)
}

::google::protobuf::uint8* HexaPos::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.HexaPos)
  // optional .protoduck.HexaPos.HexaType type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pos_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.HexaPos)
  return target;
}

int HexaPos::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.HexaPos)
  int total_size = 0;

  // optional .protoduck.HexaPos.HexaType type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HexaPos::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.HexaPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HexaPos* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HexaPos>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.HexaPos)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.HexaPos)
    MergeFrom(*source);
  }
}

void HexaPos::MergeFrom(const HexaPos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.HexaPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.has_pos()) {
    mutable_pos()->::protoduck::Pos::MergeFrom(from.pos());
  }
}

void HexaPos::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.HexaPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HexaPos::CopyFrom(const HexaPos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.HexaPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HexaPos::IsInitialized() const {

  return true;
}

void HexaPos::Swap(HexaPos* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HexaPos::InternalSwap(HexaPos* other) {
  std::swap(type_, other->type_);
  std::swap(pos_, other->pos_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HexaPos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HexaPos_descriptor_;
  metadata.reflection = HexaPos_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HexaPos

// optional .protoduck.HexaPos.HexaType type = 1;
void HexaPos::clear_type() {
  type_ = 0;
}
 ::protoduck::HexaPos_HexaType HexaPos::type() const {
  // @@protoc_insertion_point(field_get:protoduck.HexaPos.type)
  return static_cast< ::protoduck::HexaPos_HexaType >(type_);
}
 void HexaPos::set_type(::protoduck::HexaPos_HexaType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HexaPos.type)
}

// optional .protoduck.Pos pos = 2;
bool HexaPos::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
void HexaPos::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
const ::protoduck::Pos& HexaPos::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.HexaPos.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::protoduck::Pos* HexaPos::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.HexaPos.pos)
  return pos_;
}
::protoduck::Pos* HexaPos::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.HexaPos.pos)
  
  ::protoduck::Pos* temp = pos_;
  pos_ = NULL;
  return temp;
}
void HexaPos::set_allocated_pos(::protoduck::Pos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.HexaPos.pos)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PlayerPos::kArucoIdFieldNumber;
const int PlayerPos::kPosFieldNumber;
const int PlayerPos::kSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PlayerPos::PlayerPos()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.PlayerPos)
}

void PlayerPos::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  pos_ = const_cast< ::protoduck::Pos*>(&::protoduck::Pos::default_instance());
  speed_ = const_cast< ::protoduck::Speed*>(&::protoduck::Speed::default_instance());
}

PlayerPos::PlayerPos(const PlayerPos& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.PlayerPos)
}

void PlayerPos::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  aruco_id_ = 0u;
  pos_ = NULL;
  speed_ = NULL;
}

PlayerPos::~PlayerPos() {
  // @@protoc_insertion_point(destructor:protoduck.PlayerPos)
  SharedDtor();
}

void PlayerPos::SharedDtor() {
  if (this != default_instance_) {
    delete pos_;
    delete speed_;
  }
}

void PlayerPos::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PlayerPos::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PlayerPos_descriptor_;
}

const PlayerPos& PlayerPos::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

PlayerPos* PlayerPos::default_instance_ = NULL;

PlayerPos* PlayerPos::New(::google::protobuf::Arena* arena) const {
  PlayerPos* n = new PlayerPos;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PlayerPos::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.PlayerPos)
  aruco_id_ = 0u;
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
  if (GetArenaNoVirtual() == NULL && speed_ != NULL) delete speed_;
  speed_ = NULL;
}

bool PlayerPos::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.PlayerPos)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 aruco_id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &aruco_id_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_pos;
        break;
      }

      // optional .protoduck.Pos pos = 2;
      case 2: {
        if (tag == 18) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_speed;
        break;
      }

      // optional .protoduck.Speed speed = 3;
      case 3: {
        if (tag == 26) {
         parse_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.PlayerPos)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.PlayerPos)
  return false;
#undef DO_
}

void PlayerPos::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.PlayerPos)
  // optional uint32 aruco_id = 1;
  if (this->aruco_id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->aruco_id(), output);
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->pos_, output);
  }

  // optional .protoduck.Speed speed = 3;
  if (this->has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->speed_, output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.PlayerPos)
}

::google::protobuf::uint8* PlayerPos::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.PlayerPos)
  // optional uint32 aruco_id = 1;
  if (this->aruco_id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->aruco_id(), target);
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->pos_, false, target);
  }

  // optional .protoduck.Speed speed = 3;
  if (this->has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->speed_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.PlayerPos)
  return target;
}

int PlayerPos::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.PlayerPos)
  int total_size = 0;

  // optional uint32 aruco_id = 1;
  if (this->aruco_id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->aruco_id());
  }

  // optional .protoduck.Pos pos = 2;
  if (this->has_pos()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->pos_);
  }

  // optional .protoduck.Speed speed = 3;
  if (this->has_speed()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->speed_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PlayerPos::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.PlayerPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PlayerPos* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PlayerPos>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.PlayerPos)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.PlayerPos)
    MergeFrom(*source);
  }
}

void PlayerPos::MergeFrom(const PlayerPos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.PlayerPos)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.aruco_id() != 0) {
    set_aruco_id(from.aruco_id());
  }
  if (from.has_pos()) {
    mutable_pos()->::protoduck::Pos::MergeFrom(from.pos());
  }
  if (from.has_speed()) {
    mutable_speed()->::protoduck::Speed::MergeFrom(from.speed());
  }
}

void PlayerPos::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.PlayerPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PlayerPos::CopyFrom(const PlayerPos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.PlayerPos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PlayerPos::IsInitialized() const {

  return true;
}

void PlayerPos::Swap(PlayerPos* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PlayerPos::InternalSwap(PlayerPos* other) {
  std::swap(aruco_id_, other->aruco_id_);
  std::swap(pos_, other->pos_);
  std::swap(speed_, other->speed_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PlayerPos::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PlayerPos_descriptor_;
  metadata.reflection = PlayerPos_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PlayerPos

// optional uint32 aruco_id = 1;
void PlayerPos::clear_aruco_id() {
  aruco_id_ = 0u;
}
 ::google::protobuf::uint32 PlayerPos::aruco_id() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.aruco_id)
  return aruco_id_;
}
 void PlayerPos::set_aruco_id(::google::protobuf::uint32 value) {
  
  aruco_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.PlayerPos.aruco_id)
}

// optional .protoduck.Pos pos = 2;
bool PlayerPos::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
void PlayerPos::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
const ::protoduck::Pos& PlayerPos::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
::protoduck::Pos* PlayerPos::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.PlayerPos.pos)
  return pos_;
}
::protoduck::Pos* PlayerPos::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.PlayerPos.pos)
  
  ::protoduck::Pos* temp = pos_;
  pos_ = NULL;
  return temp;
}
void PlayerPos::set_allocated_pos(::protoduck::Pos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.PlayerPos.pos)
}

// optional .protoduck.Speed speed = 3;
bool PlayerPos::has_speed() const {
  return !_is_default_instance_ && speed_ != NULL;
}
void PlayerPos::clear_speed() {
  if (GetArenaNoVirtual() == NULL && speed_ != NULL) delete speed_;
  speed_ = NULL;
}
const ::protoduck::Speed& PlayerPos::speed() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.speed)
  return speed_ != NULL ? *speed_ : *default_instance_->speed_;
}
::protoduck::Speed* PlayerPos::mutable_speed() {
  
  if (speed_ == NULL) {
    speed_ = new ::protoduck::Speed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.PlayerPos.speed)
  return speed_;
}
::protoduck::Speed* PlayerPos::release_speed() {
  // @@protoc_insertion_point(field_release:protoduck.PlayerPos.speed)
  
  ::protoduck::Speed* temp = speed_;
  speed_ = NULL;
  return temp;
}
void PlayerPos::set_allocated_speed(::protoduck::Speed* speed) {
  delete speed_;
  speed_ = speed;
  if (speed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.PlayerPos.speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Message_MsgType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_MsgType_descriptor_;
}
bool Message_MsgType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Message_MsgType Message::STATUS;
const Message_MsgType Message::COMMAND;
const Message_MsgType Message::MsgType_MIN;
const Message_MsgType Message::MsgType_MAX;
const int Message::MsgType_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Message_Agent_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_Agent_descriptor_;
}
bool Message_Agent_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Message_Agent Message::DIFF;
const Message_Agent Message::HOLO;
const Message_Agent Message::RASPI;
const Message_Agent Message::MAT;
const Message_Agent Message::PC;
const Message_Agent Message::Agent_MIN;
const Message_Agent Message::Agent_MAX;
const int Message::Agent_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Message::kSourceFieldNumber;
const int Message::kMsgTypeFieldNumber;
const int Message::kPosFieldNumber;
const int Message::kSpeedFieldNumber;
const int Message::kMotorsSpeedFieldNumber;
const int Message::kMotorsCmdFieldNumber;
const int Message::kMotorPidFieldNumber;
const int Message::kBatFieldNumber;
const int Message::kArmFieldNumber;
const int Message::kHatFieldNumber;
const int Message::kHmiFieldNumber;
const int Message::kProcedureCmdFieldNumber;
const int Message::kProcedureStatusFieldNumber;
const int Message::kHexaPosFieldNumber;
const int Message::kPlayerPosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Message::Message()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:protoduck.Message)
}

void Message::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  Message_default_oneof_instance_->pos_ = const_cast< ::protoduck::Pos*>(&::protoduck::Pos::default_instance());
  Message_default_oneof_instance_->speed_ = const_cast< ::protoduck::Speed*>(&::protoduck::Speed::default_instance());
  Message_default_oneof_instance_->motors_speed_ = const_cast< ::protoduck::MotorsSpeed*>(&::protoduck::MotorsSpeed::default_instance());
  Message_default_oneof_instance_->motors_cmd_ = const_cast< ::protoduck::MotorsCmd*>(&::protoduck::MotorsCmd::default_instance());
  Message_default_oneof_instance_->motor_pid_ = const_cast< ::protoduck::MotorPid*>(&::protoduck::MotorPid::default_instance());
  Message_default_oneof_instance_->bat_ = const_cast< ::protoduck::Bat*>(&::protoduck::Bat::default_instance());
  Message_default_oneof_instance_->arm_ = const_cast< ::protoduck::Arm*>(&::protoduck::Arm::default_instance());
  Message_default_oneof_instance_->hat_ = const_cast< ::protoduck::Hat*>(&::protoduck::Hat::default_instance());
  Message_default_oneof_instance_->hmi_ = const_cast< ::protoduck::HMI*>(&::protoduck::HMI::default_instance());
  Message_default_oneof_instance_->procedure_cmd_ = const_cast< ::protoduck::ProcedureCmd*>(&::protoduck::ProcedureCmd::default_instance());
  Message_default_oneof_instance_->procedure_status_ = const_cast< ::protoduck::ProcedureStatus*>(&::protoduck::ProcedureStatus::default_instance());
  Message_default_oneof_instance_->hexa_pos_ = const_cast< ::protoduck::HexaPos*>(&::protoduck::HexaPos::default_instance());
  Message_default_oneof_instance_->player_pos_ = const_cast< ::protoduck::PlayerPos*>(&::protoduck::PlayerPos::default_instance());
}

Message::Message(const Message& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:protoduck.Message)
}

void Message::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  source_ = 0;
  msg_type_ = 0;
  clear_has_inner();
}

Message::~Message() {
  // @@protoc_insertion_point(destructor:protoduck.Message)
  SharedDtor();
}

void Message::SharedDtor() {
  if (has_inner()) {
    clear_inner();
  }
  if (this != default_instance_) {
  }
}

void Message::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Message::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Message_descriptor_;
}

const Message& Message::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_messages_2eproto();
  return *default_instance_;
}

Message* Message::default_instance_ = NULL;

Message* Message::New(::google::protobuf::Arena* arena) const {
  Message* n = new Message;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Message::clear_inner() {
// @@protoc_insertion_point(one_of_clear_start:protoduck.Message)
  switch(inner_case()) {
    case kPos: {
      delete inner_.pos_;
      break;
    }
    case kSpeed: {
      delete inner_.speed_;
      break;
    }
    case kMotorsSpeed: {
      delete inner_.motors_speed_;
      break;
    }
    case kMotorsCmd: {
      delete inner_.motors_cmd_;
      break;
    }
    case kMotorPid: {
      delete inner_.motor_pid_;
      break;
    }
    case kBat: {
      delete inner_.bat_;
      break;
    }
    case kArm: {
      delete inner_.arm_;
      break;
    }
    case kHat: {
      delete inner_.hat_;
      break;
    }
    case kHmi: {
      delete inner_.hmi_;
      break;
    }
    case kProcedureCmd: {
      delete inner_.procedure_cmd_;
      break;
    }
    case kProcedureStatus: {
      delete inner_.procedure_status_;
      break;
    }
    case kHexaPos: {
      delete inner_.hexa_pos_;
      break;
    }
    case kPlayerPos: {
      delete inner_.player_pos_;
      break;
    }
    case INNER_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = INNER_NOT_SET;
}


void Message::Clear() {
// @@protoc_insertion_point(message_clear_start:protoduck.Message)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Message, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Message*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(source_, msg_type_);

#undef ZR_HELPER_
#undef ZR_

  clear_inner();
}

bool Message::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:protoduck.Message)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .protoduck.Message.Agent source = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_source(static_cast< ::protoduck::Message_Agent >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_msg_type;
        break;
      }

      // optional .protoduck.Message.MsgType msg_type = 3;
      case 3: {
        if (tag == 24) {
         parse_msg_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_msg_type(static_cast< ::protoduck::Message_MsgType >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_pos;
        break;
      }

      // optional .protoduck.Pos pos = 4;
      case 4: {
        if (tag == 34) {
         parse_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_speed;
        break;
      }

      // optional .protoduck.Speed speed = 5;
      case 5: {
        if (tag == 42) {
         parse_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_speed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_motors_speed;
        break;
      }

      // optional .protoduck.MotorsSpeed motors_speed = 6;
      case 6: {
        if (tag == 50) {
         parse_motors_speed:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_motors_speed()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_motors_cmd;
        break;
      }

      // optional .protoduck.MotorsCmd motors_cmd = 7;
      case 7: {
        if (tag == 58) {
         parse_motors_cmd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_motors_cmd()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_motor_pid;
        break;
      }

      // optional .protoduck.MotorPid motor_pid = 8;
      case 8: {
        if (tag == 66) {
         parse_motor_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_motor_pid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_bat;
        break;
      }

      // optional .protoduck.Bat bat = 9;
      case 9: {
        if (tag == 74) {
         parse_bat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_bat()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_arm;
        break;
      }

      // optional .protoduck.Arm arm = 10;
      case 10: {
        if (tag == 82) {
         parse_arm:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_arm()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_hat;
        break;
      }

      // optional .protoduck.Hat hat = 11;
      case 11: {
        if (tag == 90) {
         parse_hat:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hat()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_hmi;
        break;
      }

      // optional .protoduck.HMI hmi = 12;
      case 12: {
        if (tag == 98) {
         parse_hmi:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hmi()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_procedure_cmd;
        break;
      }

      // optional .protoduck.ProcedureCmd procedure_cmd = 13;
      case 13: {
        if (tag == 106) {
         parse_procedure_cmd:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_procedure_cmd()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_procedure_status;
        break;
      }

      // optional .protoduck.ProcedureStatus procedure_status = 14;
      case 14: {
        if (tag == 114) {
         parse_procedure_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_procedure_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_hexa_pos;
        break;
      }

      // optional .protoduck.HexaPos hexa_pos = 15;
      case 15: {
        if (tag == 122) {
         parse_hexa_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hexa_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(130)) goto parse_player_pos;
        break;
      }

      // optional .protoduck.PlayerPos player_pos = 16;
      case 16: {
        if (tag == 130) {
         parse_player_pos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_player_pos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:protoduck.Message)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:protoduck.Message)
  return false;
#undef DO_
}

void Message::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:protoduck.Message)
  // optional .protoduck.Message.Agent source = 1;
  if (this->source() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->source(), output);
  }

  // optional .protoduck.Message.MsgType msg_type = 3;
  if (this->msg_type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->msg_type(), output);
  }

  // optional .protoduck.Pos pos = 4;
  if (has_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *inner_.pos_, output);
  }

  // optional .protoduck.Speed speed = 5;
  if (has_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *inner_.speed_, output);
  }

  // optional .protoduck.MotorsSpeed motors_speed = 6;
  if (has_motors_speed()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *inner_.motors_speed_, output);
  }

  // optional .protoduck.MotorsCmd motors_cmd = 7;
  if (has_motors_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *inner_.motors_cmd_, output);
  }

  // optional .protoduck.MotorPid motor_pid = 8;
  if (has_motor_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *inner_.motor_pid_, output);
  }

  // optional .protoduck.Bat bat = 9;
  if (has_bat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *inner_.bat_, output);
  }

  // optional .protoduck.Arm arm = 10;
  if (has_arm()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *inner_.arm_, output);
  }

  // optional .protoduck.Hat hat = 11;
  if (has_hat()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *inner_.hat_, output);
  }

  // optional .protoduck.HMI hmi = 12;
  if (has_hmi()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *inner_.hmi_, output);
  }

  // optional .protoduck.ProcedureCmd procedure_cmd = 13;
  if (has_procedure_cmd()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *inner_.procedure_cmd_, output);
  }

  // optional .protoduck.ProcedureStatus procedure_status = 14;
  if (has_procedure_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *inner_.procedure_status_, output);
  }

  // optional .protoduck.HexaPos hexa_pos = 15;
  if (has_hexa_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *inner_.hexa_pos_, output);
  }

  // optional .protoduck.PlayerPos player_pos = 16;
  if (has_player_pos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *inner_.player_pos_, output);
  }

  // @@protoc_insertion_point(serialize_end:protoduck.Message)
}

::google::protobuf::uint8* Message::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:protoduck.Message)
  // optional .protoduck.Message.Agent source = 1;
  if (this->source() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->source(), target);
  }

  // optional .protoduck.Message.MsgType msg_type = 3;
  if (this->msg_type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->msg_type(), target);
  }

  // optional .protoduck.Pos pos = 4;
  if (has_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *inner_.pos_, false, target);
  }

  // optional .protoduck.Speed speed = 5;
  if (has_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *inner_.speed_, false, target);
  }

  // optional .protoduck.MotorsSpeed motors_speed = 6;
  if (has_motors_speed()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *inner_.motors_speed_, false, target);
  }

  // optional .protoduck.MotorsCmd motors_cmd = 7;
  if (has_motors_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *inner_.motors_cmd_, false, target);
  }

  // optional .protoduck.MotorPid motor_pid = 8;
  if (has_motor_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *inner_.motor_pid_, false, target);
  }

  // optional .protoduck.Bat bat = 9;
  if (has_bat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *inner_.bat_, false, target);
  }

  // optional .protoduck.Arm arm = 10;
  if (has_arm()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *inner_.arm_, false, target);
  }

  // optional .protoduck.Hat hat = 11;
  if (has_hat()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *inner_.hat_, false, target);
  }

  // optional .protoduck.HMI hmi = 12;
  if (has_hmi()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *inner_.hmi_, false, target);
  }

  // optional .protoduck.ProcedureCmd procedure_cmd = 13;
  if (has_procedure_cmd()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *inner_.procedure_cmd_, false, target);
  }

  // optional .protoduck.ProcedureStatus procedure_status = 14;
  if (has_procedure_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *inner_.procedure_status_, false, target);
  }

  // optional .protoduck.HexaPos hexa_pos = 15;
  if (has_hexa_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        15, *inner_.hexa_pos_, false, target);
  }

  // optional .protoduck.PlayerPos player_pos = 16;
  if (has_player_pos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        16, *inner_.player_pos_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:protoduck.Message)
  return target;
}

int Message::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:protoduck.Message)
  int total_size = 0;

  // optional .protoduck.Message.Agent source = 1;
  if (this->source() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->source());
  }

  // optional .protoduck.Message.MsgType msg_type = 3;
  if (this->msg_type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->msg_type());
  }

  switch (inner_case()) {
    // optional .protoduck.Pos pos = 4;
    case kPos: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.pos_);
      break;
    }
    // optional .protoduck.Speed speed = 5;
    case kSpeed: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.speed_);
      break;
    }
    // optional .protoduck.MotorsSpeed motors_speed = 6;
    case kMotorsSpeed: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.motors_speed_);
      break;
    }
    // optional .protoduck.MotorsCmd motors_cmd = 7;
    case kMotorsCmd: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.motors_cmd_);
      break;
    }
    // optional .protoduck.MotorPid motor_pid = 8;
    case kMotorPid: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.motor_pid_);
      break;
    }
    // optional .protoduck.Bat bat = 9;
    case kBat: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.bat_);
      break;
    }
    // optional .protoduck.Arm arm = 10;
    case kArm: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.arm_);
      break;
    }
    // optional .protoduck.Hat hat = 11;
    case kHat: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.hat_);
      break;
    }
    // optional .protoduck.HMI hmi = 12;
    case kHmi: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.hmi_);
      break;
    }
    // optional .protoduck.ProcedureCmd procedure_cmd = 13;
    case kProcedureCmd: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.procedure_cmd_);
      break;
    }
    // optional .protoduck.ProcedureStatus procedure_status = 14;
    case kProcedureStatus: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.procedure_status_);
      break;
    }
    // optional .protoduck.HexaPos hexa_pos = 15;
    case kHexaPos: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.hexa_pos_);
      break;
    }
    // optional .protoduck.PlayerPos player_pos = 16;
    case kPlayerPos: {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *inner_.player_pos_);
      break;
    }
    case INNER_NOT_SET: {
      break;
    }
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Message::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:protoduck.Message)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Message* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Message>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:protoduck.Message)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:protoduck.Message)
    MergeFrom(*source);
  }
}

void Message::MergeFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:protoduck.Message)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  switch (from.inner_case()) {
    case kPos: {
      mutable_pos()->::protoduck::Pos::MergeFrom(from.pos());
      break;
    }
    case kSpeed: {
      mutable_speed()->::protoduck::Speed::MergeFrom(from.speed());
      break;
    }
    case kMotorsSpeed: {
      mutable_motors_speed()->::protoduck::MotorsSpeed::MergeFrom(from.motors_speed());
      break;
    }
    case kMotorsCmd: {
      mutable_motors_cmd()->::protoduck::MotorsCmd::MergeFrom(from.motors_cmd());
      break;
    }
    case kMotorPid: {
      mutable_motor_pid()->::protoduck::MotorPid::MergeFrom(from.motor_pid());
      break;
    }
    case kBat: {
      mutable_bat()->::protoduck::Bat::MergeFrom(from.bat());
      break;
    }
    case kArm: {
      mutable_arm()->::protoduck::Arm::MergeFrom(from.arm());
      break;
    }
    case kHat: {
      mutable_hat()->::protoduck::Hat::MergeFrom(from.hat());
      break;
    }
    case kHmi: {
      mutable_hmi()->::protoduck::HMI::MergeFrom(from.hmi());
      break;
    }
    case kProcedureCmd: {
      mutable_procedure_cmd()->::protoduck::ProcedureCmd::MergeFrom(from.procedure_cmd());
      break;
    }
    case kProcedureStatus: {
      mutable_procedure_status()->::protoduck::ProcedureStatus::MergeFrom(from.procedure_status());
      break;
    }
    case kHexaPos: {
      mutable_hexa_pos()->::protoduck::HexaPos::MergeFrom(from.hexa_pos());
      break;
    }
    case kPlayerPos: {
      mutable_player_pos()->::protoduck::PlayerPos::MergeFrom(from.player_pos());
      break;
    }
    case INNER_NOT_SET: {
      break;
    }
  }
  if (from.source() != 0) {
    set_source(from.source());
  }
  if (from.msg_type() != 0) {
    set_msg_type(from.msg_type());
  }
}

void Message::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:protoduck.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Message::CopyFrom(const Message& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:protoduck.Message)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Message::IsInitialized() const {

  return true;
}

void Message::Swap(Message* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Message::InternalSwap(Message* other) {
  std::swap(source_, other->source_);
  std::swap(msg_type_, other->msg_type_);
  std::swap(inner_, other->inner_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Message::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Message_descriptor_;
  metadata.reflection = Message_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Message

// optional .protoduck.Message.Agent source = 1;
void Message::clear_source() {
  source_ = 0;
}
 ::protoduck::Message_Agent Message::source() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.source)
  return static_cast< ::protoduck::Message_Agent >(source_);
}
 void Message::set_source(::protoduck::Message_Agent value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Message.source)
}

// optional .protoduck.Message.MsgType msg_type = 3;
void Message::clear_msg_type() {
  msg_type_ = 0;
}
 ::protoduck::Message_MsgType Message::msg_type() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.msg_type)
  return static_cast< ::protoduck::Message_MsgType >(msg_type_);
}
 void Message::set_msg_type(::protoduck::Message_MsgType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Message.msg_type)
}

// optional .protoduck.Pos pos = 4;
bool Message::has_pos() const {
  return inner_case() == kPos;
}
void Message::set_has_pos() {
  _oneof_case_[0] = kPos;
}
void Message::clear_pos() {
  if (has_pos()) {
    delete inner_.pos_;
    clear_has_inner();
  }
}
 const ::protoduck::Pos& Message::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.pos)
  return has_pos()
      ? *inner_.pos_
      : ::protoduck::Pos::default_instance();
}
::protoduck::Pos* Message::mutable_pos() {
  if (!has_pos()) {
    clear_inner();
    set_has_pos();
    inner_.pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.pos)
  return inner_.pos_;
}
::protoduck::Pos* Message::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.pos)
  if (has_pos()) {
    clear_has_inner();
    ::protoduck::Pos* temp = inner_.pos_;
    inner_.pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_pos(::protoduck::Pos* pos) {
  clear_inner();
  if (pos) {
    set_has_pos();
    inner_.pos_ = pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.pos)
}

// optional .protoduck.Speed speed = 5;
bool Message::has_speed() const {
  return inner_case() == kSpeed;
}
void Message::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
void Message::clear_speed() {
  if (has_speed()) {
    delete inner_.speed_;
    clear_has_inner();
  }
}
 const ::protoduck::Speed& Message::speed() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.speed)
  return has_speed()
      ? *inner_.speed_
      : ::protoduck::Speed::default_instance();
}
::protoduck::Speed* Message::mutable_speed() {
  if (!has_speed()) {
    clear_inner();
    set_has_speed();
    inner_.speed_ = new ::protoduck::Speed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.speed)
  return inner_.speed_;
}
::protoduck::Speed* Message::release_speed() {
  // @@protoc_insertion_point(field_release:protoduck.Message.speed)
  if (has_speed()) {
    clear_has_inner();
    ::protoduck::Speed* temp = inner_.speed_;
    inner_.speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_speed(::protoduck::Speed* speed) {
  clear_inner();
  if (speed) {
    set_has_speed();
    inner_.speed_ = speed;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.speed)
}

// optional .protoduck.MotorsSpeed motors_speed = 6;
bool Message::has_motors_speed() const {
  return inner_case() == kMotorsSpeed;
}
void Message::set_has_motors_speed() {
  _oneof_case_[0] = kMotorsSpeed;
}
void Message::clear_motors_speed() {
  if (has_motors_speed()) {
    delete inner_.motors_speed_;
    clear_has_inner();
  }
}
 const ::protoduck::MotorsSpeed& Message::motors_speed() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motors_speed)
  return has_motors_speed()
      ? *inner_.motors_speed_
      : ::protoduck::MotorsSpeed::default_instance();
}
::protoduck::MotorsSpeed* Message::mutable_motors_speed() {
  if (!has_motors_speed()) {
    clear_inner();
    set_has_motors_speed();
    inner_.motors_speed_ = new ::protoduck::MotorsSpeed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motors_speed)
  return inner_.motors_speed_;
}
::protoduck::MotorsSpeed* Message::release_motors_speed() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motors_speed)
  if (has_motors_speed()) {
    clear_has_inner();
    ::protoduck::MotorsSpeed* temp = inner_.motors_speed_;
    inner_.motors_speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_motors_speed(::protoduck::MotorsSpeed* motors_speed) {
  clear_inner();
  if (motors_speed) {
    set_has_motors_speed();
    inner_.motors_speed_ = motors_speed;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motors_speed)
}

// optional .protoduck.MotorsCmd motors_cmd = 7;
bool Message::has_motors_cmd() const {
  return inner_case() == kMotorsCmd;
}
void Message::set_has_motors_cmd() {
  _oneof_case_[0] = kMotorsCmd;
}
void Message::clear_motors_cmd() {
  if (has_motors_cmd()) {
    delete inner_.motors_cmd_;
    clear_has_inner();
  }
}
 const ::protoduck::MotorsCmd& Message::motors_cmd() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motors_cmd)
  return has_motors_cmd()
      ? *inner_.motors_cmd_
      : ::protoduck::MotorsCmd::default_instance();
}
::protoduck::MotorsCmd* Message::mutable_motors_cmd() {
  if (!has_motors_cmd()) {
    clear_inner();
    set_has_motors_cmd();
    inner_.motors_cmd_ = new ::protoduck::MotorsCmd;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motors_cmd)
  return inner_.motors_cmd_;
}
::protoduck::MotorsCmd* Message::release_motors_cmd() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motors_cmd)
  if (has_motors_cmd()) {
    clear_has_inner();
    ::protoduck::MotorsCmd* temp = inner_.motors_cmd_;
    inner_.motors_cmd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_motors_cmd(::protoduck::MotorsCmd* motors_cmd) {
  clear_inner();
  if (motors_cmd) {
    set_has_motors_cmd();
    inner_.motors_cmd_ = motors_cmd;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motors_cmd)
}

// optional .protoduck.MotorPid motor_pid = 8;
bool Message::has_motor_pid() const {
  return inner_case() == kMotorPid;
}
void Message::set_has_motor_pid() {
  _oneof_case_[0] = kMotorPid;
}
void Message::clear_motor_pid() {
  if (has_motor_pid()) {
    delete inner_.motor_pid_;
    clear_has_inner();
  }
}
 const ::protoduck::MotorPid& Message::motor_pid() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motor_pid)
  return has_motor_pid()
      ? *inner_.motor_pid_
      : ::protoduck::MotorPid::default_instance();
}
::protoduck::MotorPid* Message::mutable_motor_pid() {
  if (!has_motor_pid()) {
    clear_inner();
    set_has_motor_pid();
    inner_.motor_pid_ = new ::protoduck::MotorPid;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motor_pid)
  return inner_.motor_pid_;
}
::protoduck::MotorPid* Message::release_motor_pid() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motor_pid)
  if (has_motor_pid()) {
    clear_has_inner();
    ::protoduck::MotorPid* temp = inner_.motor_pid_;
    inner_.motor_pid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_motor_pid(::protoduck::MotorPid* motor_pid) {
  clear_inner();
  if (motor_pid) {
    set_has_motor_pid();
    inner_.motor_pid_ = motor_pid;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motor_pid)
}

// optional .protoduck.Bat bat = 9;
bool Message::has_bat() const {
  return inner_case() == kBat;
}
void Message::set_has_bat() {
  _oneof_case_[0] = kBat;
}
void Message::clear_bat() {
  if (has_bat()) {
    delete inner_.bat_;
    clear_has_inner();
  }
}
 const ::protoduck::Bat& Message::bat() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.bat)
  return has_bat()
      ? *inner_.bat_
      : ::protoduck::Bat::default_instance();
}
::protoduck::Bat* Message::mutable_bat() {
  if (!has_bat()) {
    clear_inner();
    set_has_bat();
    inner_.bat_ = new ::protoduck::Bat;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.bat)
  return inner_.bat_;
}
::protoduck::Bat* Message::release_bat() {
  // @@protoc_insertion_point(field_release:protoduck.Message.bat)
  if (has_bat()) {
    clear_has_inner();
    ::protoduck::Bat* temp = inner_.bat_;
    inner_.bat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_bat(::protoduck::Bat* bat) {
  clear_inner();
  if (bat) {
    set_has_bat();
    inner_.bat_ = bat;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.bat)
}

// optional .protoduck.Arm arm = 10;
bool Message::has_arm() const {
  return inner_case() == kArm;
}
void Message::set_has_arm() {
  _oneof_case_[0] = kArm;
}
void Message::clear_arm() {
  if (has_arm()) {
    delete inner_.arm_;
    clear_has_inner();
  }
}
 const ::protoduck::Arm& Message::arm() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.arm)
  return has_arm()
      ? *inner_.arm_
      : ::protoduck::Arm::default_instance();
}
::protoduck::Arm* Message::mutable_arm() {
  if (!has_arm()) {
    clear_inner();
    set_has_arm();
    inner_.arm_ = new ::protoduck::Arm;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.arm)
  return inner_.arm_;
}
::protoduck::Arm* Message::release_arm() {
  // @@protoc_insertion_point(field_release:protoduck.Message.arm)
  if (has_arm()) {
    clear_has_inner();
    ::protoduck::Arm* temp = inner_.arm_;
    inner_.arm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_arm(::protoduck::Arm* arm) {
  clear_inner();
  if (arm) {
    set_has_arm();
    inner_.arm_ = arm;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.arm)
}

// optional .protoduck.Hat hat = 11;
bool Message::has_hat() const {
  return inner_case() == kHat;
}
void Message::set_has_hat() {
  _oneof_case_[0] = kHat;
}
void Message::clear_hat() {
  if (has_hat()) {
    delete inner_.hat_;
    clear_has_inner();
  }
}
 const ::protoduck::Hat& Message::hat() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hat)
  return has_hat()
      ? *inner_.hat_
      : ::protoduck::Hat::default_instance();
}
::protoduck::Hat* Message::mutable_hat() {
  if (!has_hat()) {
    clear_inner();
    set_has_hat();
    inner_.hat_ = new ::protoduck::Hat;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hat)
  return inner_.hat_;
}
::protoduck::Hat* Message::release_hat() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hat)
  if (has_hat()) {
    clear_has_inner();
    ::protoduck::Hat* temp = inner_.hat_;
    inner_.hat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_hat(::protoduck::Hat* hat) {
  clear_inner();
  if (hat) {
    set_has_hat();
    inner_.hat_ = hat;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hat)
}

// optional .protoduck.HMI hmi = 12;
bool Message::has_hmi() const {
  return inner_case() == kHmi;
}
void Message::set_has_hmi() {
  _oneof_case_[0] = kHmi;
}
void Message::clear_hmi() {
  if (has_hmi()) {
    delete inner_.hmi_;
    clear_has_inner();
  }
}
 const ::protoduck::HMI& Message::hmi() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hmi)
  return has_hmi()
      ? *inner_.hmi_
      : ::protoduck::HMI::default_instance();
}
::protoduck::HMI* Message::mutable_hmi() {
  if (!has_hmi()) {
    clear_inner();
    set_has_hmi();
    inner_.hmi_ = new ::protoduck::HMI;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hmi)
  return inner_.hmi_;
}
::protoduck::HMI* Message::release_hmi() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hmi)
  if (has_hmi()) {
    clear_has_inner();
    ::protoduck::HMI* temp = inner_.hmi_;
    inner_.hmi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_hmi(::protoduck::HMI* hmi) {
  clear_inner();
  if (hmi) {
    set_has_hmi();
    inner_.hmi_ = hmi;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hmi)
}

// optional .protoduck.ProcedureCmd procedure_cmd = 13;
bool Message::has_procedure_cmd() const {
  return inner_case() == kProcedureCmd;
}
void Message::set_has_procedure_cmd() {
  _oneof_case_[0] = kProcedureCmd;
}
void Message::clear_procedure_cmd() {
  if (has_procedure_cmd()) {
    delete inner_.procedure_cmd_;
    clear_has_inner();
  }
}
 const ::protoduck::ProcedureCmd& Message::procedure_cmd() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.procedure_cmd)
  return has_procedure_cmd()
      ? *inner_.procedure_cmd_
      : ::protoduck::ProcedureCmd::default_instance();
}
::protoduck::ProcedureCmd* Message::mutable_procedure_cmd() {
  if (!has_procedure_cmd()) {
    clear_inner();
    set_has_procedure_cmd();
    inner_.procedure_cmd_ = new ::protoduck::ProcedureCmd;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.procedure_cmd)
  return inner_.procedure_cmd_;
}
::protoduck::ProcedureCmd* Message::release_procedure_cmd() {
  // @@protoc_insertion_point(field_release:protoduck.Message.procedure_cmd)
  if (has_procedure_cmd()) {
    clear_has_inner();
    ::protoduck::ProcedureCmd* temp = inner_.procedure_cmd_;
    inner_.procedure_cmd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_procedure_cmd(::protoduck::ProcedureCmd* procedure_cmd) {
  clear_inner();
  if (procedure_cmd) {
    set_has_procedure_cmd();
    inner_.procedure_cmd_ = procedure_cmd;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.procedure_cmd)
}

// optional .protoduck.ProcedureStatus procedure_status = 14;
bool Message::has_procedure_status() const {
  return inner_case() == kProcedureStatus;
}
void Message::set_has_procedure_status() {
  _oneof_case_[0] = kProcedureStatus;
}
void Message::clear_procedure_status() {
  if (has_procedure_status()) {
    delete inner_.procedure_status_;
    clear_has_inner();
  }
}
 const ::protoduck::ProcedureStatus& Message::procedure_status() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.procedure_status)
  return has_procedure_status()
      ? *inner_.procedure_status_
      : ::protoduck::ProcedureStatus::default_instance();
}
::protoduck::ProcedureStatus* Message::mutable_procedure_status() {
  if (!has_procedure_status()) {
    clear_inner();
    set_has_procedure_status();
    inner_.procedure_status_ = new ::protoduck::ProcedureStatus;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.procedure_status)
  return inner_.procedure_status_;
}
::protoduck::ProcedureStatus* Message::release_procedure_status() {
  // @@protoc_insertion_point(field_release:protoduck.Message.procedure_status)
  if (has_procedure_status()) {
    clear_has_inner();
    ::protoduck::ProcedureStatus* temp = inner_.procedure_status_;
    inner_.procedure_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_procedure_status(::protoduck::ProcedureStatus* procedure_status) {
  clear_inner();
  if (procedure_status) {
    set_has_procedure_status();
    inner_.procedure_status_ = procedure_status;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.procedure_status)
}

// optional .protoduck.HexaPos hexa_pos = 15;
bool Message::has_hexa_pos() const {
  return inner_case() == kHexaPos;
}
void Message::set_has_hexa_pos() {
  _oneof_case_[0] = kHexaPos;
}
void Message::clear_hexa_pos() {
  if (has_hexa_pos()) {
    delete inner_.hexa_pos_;
    clear_has_inner();
  }
}
 const ::protoduck::HexaPos& Message::hexa_pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hexa_pos)
  return has_hexa_pos()
      ? *inner_.hexa_pos_
      : ::protoduck::HexaPos::default_instance();
}
::protoduck::HexaPos* Message::mutable_hexa_pos() {
  if (!has_hexa_pos()) {
    clear_inner();
    set_has_hexa_pos();
    inner_.hexa_pos_ = new ::protoduck::HexaPos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hexa_pos)
  return inner_.hexa_pos_;
}
::protoduck::HexaPos* Message::release_hexa_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hexa_pos)
  if (has_hexa_pos()) {
    clear_has_inner();
    ::protoduck::HexaPos* temp = inner_.hexa_pos_;
    inner_.hexa_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_hexa_pos(::protoduck::HexaPos* hexa_pos) {
  clear_inner();
  if (hexa_pos) {
    set_has_hexa_pos();
    inner_.hexa_pos_ = hexa_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hexa_pos)
}

// optional .protoduck.PlayerPos player_pos = 16;
bool Message::has_player_pos() const {
  return inner_case() == kPlayerPos;
}
void Message::set_has_player_pos() {
  _oneof_case_[0] = kPlayerPos;
}
void Message::clear_player_pos() {
  if (has_player_pos()) {
    delete inner_.player_pos_;
    clear_has_inner();
  }
}
 const ::protoduck::PlayerPos& Message::player_pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.player_pos)
  return has_player_pos()
      ? *inner_.player_pos_
      : ::protoduck::PlayerPos::default_instance();
}
::protoduck::PlayerPos* Message::mutable_player_pos() {
  if (!has_player_pos()) {
    clear_inner();
    set_has_player_pos();
    inner_.player_pos_ = new ::protoduck::PlayerPos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.player_pos)
  return inner_.player_pos_;
}
::protoduck::PlayerPos* Message::release_player_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.player_pos)
  if (has_player_pos()) {
    clear_has_inner();
    ::protoduck::PlayerPos* temp = inner_.player_pos_;
    inner_.player_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void Message::set_allocated_player_pos(::protoduck::PlayerPos* player_pos) {
  clear_inner();
  if (player_pos) {
    set_has_player_pos();
    inner_.player_pos_ = player_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.player_pos)
}

bool Message::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
void Message::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
Message::InnerCase Message::inner_case() const {
  return Message::InnerCase(_oneof_case_[0]);
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace protoduck

// @@protoc_insertion_point(global_scope)
