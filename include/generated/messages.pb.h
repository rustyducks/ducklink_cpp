// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protoduck {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_messages_2eproto();
void protobuf_AssignDesc_messages_2eproto();
void protobuf_ShutdownFile_messages_2eproto();

class Arm;
class Bat;
class HMI;
class Hat;
class HexaPos;
class Message;
class MotorPid;
class MotorsCmd;
class MotorsSpeed;
class PlayerPos;
class Pos;
class ProcedureCmd;
class ProcedureStatus;
class Speed;

enum ProcedureCmd_Procedure {
  ProcedureCmd_Procedure_HOME = 0,
  ProcedureCmd_Procedure_PUT_ON_STACK = 1,
  ProcedureCmd_Procedure_TURN_AND_PUT_ON_STACK = 2,
  ProcedureCmd_Procedure_TAKE_FROM_STACK = 3,
  ProcedureCmd_Procedure_ProcedureCmd_Procedure_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProcedureCmd_Procedure_ProcedureCmd_Procedure_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProcedureCmd_Procedure_IsValid(int value);
const ProcedureCmd_Procedure ProcedureCmd_Procedure_Procedure_MIN = ProcedureCmd_Procedure_HOME;
const ProcedureCmd_Procedure ProcedureCmd_Procedure_Procedure_MAX = ProcedureCmd_Procedure_TAKE_FROM_STACK;
const int ProcedureCmd_Procedure_Procedure_ARRAYSIZE = ProcedureCmd_Procedure_Procedure_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcedureCmd_Procedure_descriptor();
inline const ::std::string& ProcedureCmd_Procedure_Name(ProcedureCmd_Procedure value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcedureCmd_Procedure_descriptor(), value);
}
inline bool ProcedureCmd_Procedure_Parse(
    const ::std::string& name, ProcedureCmd_Procedure* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcedureCmd_Procedure>(
    ProcedureCmd_Procedure_descriptor(), name, value);
}
enum ProcedureStatus_Status {
  ProcedureStatus_Status_SUCCESS = 0,
  ProcedureStatus_Status_RUNNING = 1,
  ProcedureStatus_Status_FAILURE = 2,
  ProcedureStatus_Status_POSITION_UNREACHABLE = 3,
  ProcedureStatus_Status_UNABLE_VACUUM = 4,
  ProcedureStatus_Status_ProcedureStatus_Status_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ProcedureStatus_Status_ProcedureStatus_Status_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ProcedureStatus_Status_IsValid(int value);
const ProcedureStatus_Status ProcedureStatus_Status_Status_MIN = ProcedureStatus_Status_SUCCESS;
const ProcedureStatus_Status ProcedureStatus_Status_Status_MAX = ProcedureStatus_Status_UNABLE_VACUUM;
const int ProcedureStatus_Status_Status_ARRAYSIZE = ProcedureStatus_Status_Status_MAX + 1;

const ::google::protobuf::EnumDescriptor* ProcedureStatus_Status_descriptor();
inline const ::std::string& ProcedureStatus_Status_Name(ProcedureStatus_Status value) {
  return ::google::protobuf::internal::NameOfEnum(
    ProcedureStatus_Status_descriptor(), value);
}
inline bool ProcedureStatus_Status_Parse(
    const ::std::string& name, ProcedureStatus_Status* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ProcedureStatus_Status>(
    ProcedureStatus_Status_descriptor(), name, value);
}
enum HexaPos_HexaType {
  HexaPos_HexaType_ROCK = 0,
  HexaPos_HexaType_RED = 1,
  HexaPos_HexaType_GREEN = 2,
  HexaPos_HexaType_BLUE = 3,
  HexaPos_HexaType_HexaPos_HexaType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  HexaPos_HexaType_HexaPos_HexaType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool HexaPos_HexaType_IsValid(int value);
const HexaPos_HexaType HexaPos_HexaType_HexaType_MIN = HexaPos_HexaType_ROCK;
const HexaPos_HexaType HexaPos_HexaType_HexaType_MAX = HexaPos_HexaType_BLUE;
const int HexaPos_HexaType_HexaType_ARRAYSIZE = HexaPos_HexaType_HexaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* HexaPos_HexaType_descriptor();
inline const ::std::string& HexaPos_HexaType_Name(HexaPos_HexaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    HexaPos_HexaType_descriptor(), value);
}
inline bool HexaPos_HexaType_Parse(
    const ::std::string& name, HexaPos_HexaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HexaPos_HexaType>(
    HexaPos_HexaType_descriptor(), name, value);
}
enum Message_MsgType {
  Message_MsgType_STATUS = 0,
  Message_MsgType_COMMAND = 1,
  Message_MsgType_Message_MsgType_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_MsgType_Message_MsgType_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_MsgType_IsValid(int value);
const Message_MsgType Message_MsgType_MsgType_MIN = Message_MsgType_STATUS;
const Message_MsgType Message_MsgType_MsgType_MAX = Message_MsgType_COMMAND;
const int Message_MsgType_MsgType_ARRAYSIZE = Message_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_MsgType_descriptor();
inline const ::std::string& Message_MsgType_Name(Message_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_MsgType_descriptor(), value);
}
inline bool Message_MsgType_Parse(
    const ::std::string& name, Message_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_MsgType>(
    Message_MsgType_descriptor(), name, value);
}
enum Message_Agent {
  Message_Agent_DIFF = 0,
  Message_Agent_HOLO = 1,
  Message_Agent_RASPI = 2,
  Message_Agent_MAT = 3,
  Message_Agent_PC = 4,
  Message_Agent_Message_Agent_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  Message_Agent_Message_Agent_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool Message_Agent_IsValid(int value);
const Message_Agent Message_Agent_Agent_MIN = Message_Agent_DIFF;
const Message_Agent Message_Agent_Agent_MAX = Message_Agent_PC;
const int Message_Agent_Agent_ARRAYSIZE = Message_Agent_Agent_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Agent_descriptor();
inline const ::std::string& Message_Agent_Name(Message_Agent value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Agent_descriptor(), value);
}
inline bool Message_Agent_Parse(
    const ::std::string& name, Message_Agent* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Agent>(
    Message_Agent_descriptor(), name, value);
}
enum ArmID {
  ARM1 = 0,
  ARM2 = 1,
  ArmID_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  ArmID_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool ArmID_IsValid(int value);
const ArmID ArmID_MIN = ARM1;
const ArmID ArmID_MAX = ARM2;
const int ArmID_ARRAYSIZE = ArmID_MAX + 1;

const ::google::protobuf::EnumDescriptor* ArmID_descriptor();
inline const ::std::string& ArmID_Name(ArmID value) {
  return ::google::protobuf::internal::NameOfEnum(
    ArmID_descriptor(), value);
}
inline bool ArmID_Parse(
    const ::std::string& name, ArmID* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ArmID>(
    ArmID_descriptor(), name, value);
}
// ===================================================================

class Pos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Pos) */ {
 public:
  Pos();
  virtual ~Pos();

  Pos(const Pos& from);

  inline Pos& operator=(const Pos& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Pos& default_instance();

  void Swap(Pos* other);

  // implements Message ----------------------------------------------

  inline Pos* New() const { return New(NULL); }

  Pos* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Pos& from);
  void MergeFrom(const Pos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Pos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  void clear_x();
  static const int kXFieldNumber = 1;
  float x() const;
  void set_x(float value);

  // optional float y = 2;
  void clear_y();
  static const int kYFieldNumber = 2;
  float y() const;
  void set_y(float value);

  // optional float theta = 3;
  void clear_theta();
  static const int kThetaFieldNumber = 3;
  float theta() const;
  void set_theta(float value);

  // @@protoc_insertion_point(class_scope:protoduck.Pos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float x_;
  float y_;
  float theta_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Pos* default_instance_;
};
// -------------------------------------------------------------------

class Speed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Speed) */ {
 public:
  Speed();
  virtual ~Speed();

  Speed(const Speed& from);

  inline Speed& operator=(const Speed& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Speed& default_instance();

  void Swap(Speed* other);

  // implements Message ----------------------------------------------

  inline Speed* New() const { return New(NULL); }

  Speed* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Speed& from);
  void MergeFrom(const Speed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Speed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float vx = 1;
  void clear_vx();
  static const int kVxFieldNumber = 1;
  float vx() const;
  void set_vx(float value);

  // optional float vy = 2;
  void clear_vy();
  static const int kVyFieldNumber = 2;
  float vy() const;
  void set_vy(float value);

  // optional float vtheta = 3;
  void clear_vtheta();
  static const int kVthetaFieldNumber = 3;
  float vtheta() const;
  void set_vtheta(float value);

  // @@protoc_insertion_point(class_scope:protoduck.Speed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float vx_;
  float vy_;
  float vtheta_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Speed* default_instance_;
};
// -------------------------------------------------------------------

class MotorsSpeed : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.MotorsSpeed) */ {
 public:
  MotorsSpeed();
  virtual ~MotorsSpeed();

  MotorsSpeed(const MotorsSpeed& from);

  inline MotorsSpeed& operator=(const MotorsSpeed& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorsSpeed& default_instance();

  void Swap(MotorsSpeed* other);

  // implements Message ----------------------------------------------

  inline MotorsSpeed* New() const { return New(NULL); }

  MotorsSpeed* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotorsSpeed& from);
  void MergeFrom(const MotorsSpeed& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MotorsSpeed* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float v1 = 1;
  void clear_v1();
  static const int kV1FieldNumber = 1;
  float v1() const;
  void set_v1(float value);

  // optional float v2 = 2;
  void clear_v2();
  static const int kV2FieldNumber = 2;
  float v2() const;
  void set_v2(float value);

  // optional float v3 = 3;
  void clear_v3();
  static const int kV3FieldNumber = 3;
  float v3() const;
  void set_v3(float value);

  // @@protoc_insertion_point(class_scope:protoduck.MotorsSpeed)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float v1_;
  float v2_;
  float v3_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static MotorsSpeed* default_instance_;
};
// -------------------------------------------------------------------

class MotorsCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.MotorsCmd) */ {
 public:
  MotorsCmd();
  virtual ~MotorsCmd();

  MotorsCmd(const MotorsCmd& from);

  inline MotorsCmd& operator=(const MotorsCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorsCmd& default_instance();

  void Swap(MotorsCmd* other);

  // implements Message ----------------------------------------------

  inline MotorsCmd* New() const { return New(NULL); }

  MotorsCmd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotorsCmd& from);
  void MergeFrom(const MotorsCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MotorsCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float cmd1 = 1;
  void clear_cmd1();
  static const int kCmd1FieldNumber = 1;
  float cmd1() const;
  void set_cmd1(float value);

  // optional float cmd2 = 2;
  void clear_cmd2();
  static const int kCmd2FieldNumber = 2;
  float cmd2() const;
  void set_cmd2(float value);

  // optional float cmd3 = 3;
  void clear_cmd3();
  static const int kCmd3FieldNumber = 3;
  float cmd3() const;
  void set_cmd3(float value);

  // @@protoc_insertion_point(class_scope:protoduck.MotorsCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float cmd1_;
  float cmd2_;
  float cmd3_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static MotorsCmd* default_instance_;
};
// -------------------------------------------------------------------

class MotorPid : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.MotorPid) */ {
 public:
  MotorPid();
  virtual ~MotorPid();

  MotorPid(const MotorPid& from);

  inline MotorPid& operator=(const MotorPid& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MotorPid& default_instance();

  void Swap(MotorPid* other);

  // implements Message ----------------------------------------------

  inline MotorPid* New() const { return New(NULL); }

  MotorPid* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MotorPid& from);
  void MergeFrom(const MotorPid& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(MotorPid* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 motor_no = 1;
  void clear_motor_no();
  static const int kMotorNoFieldNumber = 1;
  ::google::protobuf::uint32 motor_no() const;
  void set_motor_no(::google::protobuf::uint32 value);

  // optional float feedforward = 2;
  void clear_feedforward();
  static const int kFeedforwardFieldNumber = 2;
  float feedforward() const;
  void set_feedforward(float value);

  // optional float kp = 3;
  void clear_kp();
  static const int kKpFieldNumber = 3;
  float kp() const;
  void set_kp(float value);

  // optional float ki = 4;
  void clear_ki();
  static const int kKiFieldNumber = 4;
  float ki() const;
  void set_ki(float value);

  // optional float kd = 5;
  void clear_kd();
  static const int kKdFieldNumber = 5;
  float kd() const;
  void set_kd(float value);

  // @@protoc_insertion_point(class_scope:protoduck.MotorPid)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::uint32 motor_no_;
  float feedforward_;
  float kp_;
  float ki_;
  float kd_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static MotorPid* default_instance_;
};
// -------------------------------------------------------------------

class Bat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Bat) */ {
 public:
  Bat();
  virtual ~Bat();

  Bat(const Bat& from);

  inline Bat& operator=(const Bat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Bat& default_instance();

  void Swap(Bat* other);

  // implements Message ----------------------------------------------

  inline Bat* New() const { return New(NULL); }

  Bat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Bat& from);
  void MergeFrom(const Bat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Bat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float voltage = 1;
  void clear_voltage();
  static const int kVoltageFieldNumber = 1;
  float voltage() const;
  void set_voltage(float value);

  // @@protoc_insertion_point(class_scope:protoduck.Bat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float voltage_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Bat* default_instance_;
};
// -------------------------------------------------------------------

class Arm : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Arm) */ {
 public:
  Arm();
  virtual ~Arm();

  Arm(const Arm& from);

  inline Arm& operator=(const Arm& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Arm& default_instance();

  void Swap(Arm* other);

  // implements Message ----------------------------------------------

  inline Arm* New() const { return New(NULL); }

  Arm* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Arm& from);
  void MergeFrom(const Arm& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Arm* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protoduck.ArmID arm_id = 1;
  void clear_arm_id();
  static const int kArmIdFieldNumber = 1;
  ::protoduck::ArmID arm_id() const;
  void set_arm_id(::protoduck::ArmID value);

  // optional float traZ = 2;
  void clear_traz();
  static const int kTraZFieldNumber = 2;
  float traz() const;
  void set_traz(float value);

  // optional float rotZ = 3;
  void clear_rotz();
  static const int kRotZFieldNumber = 3;
  float rotz() const;
  void set_rotz(float value);

  // optional float rotY = 4;
  void clear_roty();
  static const int kRotYFieldNumber = 4;
  float roty() const;
  void set_roty(float value);

  // optional bool pump = 5;
  void clear_pump();
  static const int kPumpFieldNumber = 5;
  bool pump() const;
  void set_pump(bool value);

  // optional bool valve = 6;
  void clear_valve();
  static const int kValveFieldNumber = 6;
  bool valve() const;
  void set_valve(bool value);

  // optional float pressure = 7;
  void clear_pressure();
  static const int kPressureFieldNumber = 7;
  float pressure() const;
  void set_pressure(float value);

  // @@protoc_insertion_point(class_scope:protoduck.Arm)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int arm_id_;
  float traz_;
  float rotz_;
  float roty_;
  bool pump_;
  bool valve_;
  float pressure_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Arm* default_instance_;
};
// -------------------------------------------------------------------

class Hat : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Hat) */ {
 public:
  Hat();
  virtual ~Hat();

  Hat(const Hat& from);

  inline Hat& operator=(const Hat& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Hat& default_instance();

  void Swap(Hat* other);

  // implements Message ----------------------------------------------

  inline Hat* New() const { return New(NULL); }

  Hat* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Hat& from);
  void MergeFrom(const Hat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Hat* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float height = 1;
  void clear_height();
  static const int kHeightFieldNumber = 1;
  float height() const;
  void set_height(float value);

  // optional bool pump = 2;
  void clear_pump();
  static const int kPumpFieldNumber = 2;
  bool pump() const;
  void set_pump(bool value);

  // optional bool valve = 3;
  void clear_valve();
  static const int kValveFieldNumber = 3;
  bool valve() const;
  void set_valve(bool value);

  // optional float pressure = 4;
  void clear_pressure();
  static const int kPressureFieldNumber = 4;
  float pressure() const;
  void set_pressure(float value);

  // @@protoc_insertion_point(class_scope:protoduck.Hat)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  float height_;
  bool pump_;
  bool valve_;
  float pressure_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Hat* default_instance_;
};
// -------------------------------------------------------------------

class HMI : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.HMI) */ {
 public:
  HMI();
  virtual ~HMI();

  HMI(const HMI& from);

  inline HMI& operator=(const HMI& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HMI& default_instance();

  void Swap(HMI* other);

  // implements Message ----------------------------------------------

  inline HMI* New() const { return New(NULL); }

  HMI* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HMI& from);
  void MergeFrom(const HMI& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HMI* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool color = 1;
  void clear_color();
  static const int kColorFieldNumber = 1;
  bool color() const;
  void set_color(bool value);

  // optional bool tirette = 2;
  void clear_tirette();
  static const int kTiretteFieldNumber = 2;
  bool tirette() const;
  void set_tirette(bool value);

  // optional bool bouton = 3;
  void clear_bouton();
  static const int kBoutonFieldNumber = 3;
  bool bouton() const;
  void set_bouton(bool value);

  // optional uint32 led = 4;
  void clear_led();
  static const int kLedFieldNumber = 4;
  ::google::protobuf::uint32 led() const;
  void set_led(::google::protobuf::uint32 value);

  // optional uint32 hmi_display = 5;
  void clear_hmi_display();
  static const int kHmiDisplayFieldNumber = 5;
  ::google::protobuf::uint32 hmi_display() const;
  void set_hmi_display(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoduck.HMI)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool color_;
  bool tirette_;
  bool bouton_;
  ::google::protobuf::uint32 led_;
  ::google::protobuf::uint32 hmi_display_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static HMI* default_instance_;
};
// -------------------------------------------------------------------

class ProcedureCmd : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.ProcedureCmd) */ {
 public:
  ProcedureCmd();
  virtual ~ProcedureCmd();

  ProcedureCmd(const ProcedureCmd& from);

  inline ProcedureCmd& operator=(const ProcedureCmd& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureCmd& default_instance();

  void Swap(ProcedureCmd* other);

  // implements Message ----------------------------------------------

  inline ProcedureCmd* New() const { return New(NULL); }

  ProcedureCmd* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcedureCmd& from);
  void MergeFrom(const ProcedureCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcedureCmd* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProcedureCmd_Procedure Procedure;
  static const Procedure HOME =
    ProcedureCmd_Procedure_HOME;
  static const Procedure PUT_ON_STACK =
    ProcedureCmd_Procedure_PUT_ON_STACK;
  static const Procedure TURN_AND_PUT_ON_STACK =
    ProcedureCmd_Procedure_TURN_AND_PUT_ON_STACK;
  static const Procedure TAKE_FROM_STACK =
    ProcedureCmd_Procedure_TAKE_FROM_STACK;
  static inline bool Procedure_IsValid(int value) {
    return ProcedureCmd_Procedure_IsValid(value);
  }
  static const Procedure Procedure_MIN =
    ProcedureCmd_Procedure_Procedure_MIN;
  static const Procedure Procedure_MAX =
    ProcedureCmd_Procedure_Procedure_MAX;
  static const int Procedure_ARRAYSIZE =
    ProcedureCmd_Procedure_Procedure_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Procedure_descriptor() {
    return ProcedureCmd_Procedure_descriptor();
  }
  static inline const ::std::string& Procedure_Name(Procedure value) {
    return ProcedureCmd_Procedure_Name(value);
  }
  static inline bool Procedure_Parse(const ::std::string& name,
      Procedure* value) {
    return ProcedureCmd_Procedure_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protoduck.ArmID arm_id = 1;
  void clear_arm_id();
  static const int kArmIdFieldNumber = 1;
  ::protoduck::ArmID arm_id() const;
  void set_arm_id(::protoduck::ArmID value);

  // optional .protoduck.ProcedureCmd.Procedure procedure = 2;
  void clear_procedure();
  static const int kProcedureFieldNumber = 2;
  ::protoduck::ProcedureCmd_Procedure procedure() const;
  void set_procedure(::protoduck::ProcedureCmd_Procedure value);

  // optional uint32 param = 3;
  void clear_param();
  static const int kParamFieldNumber = 3;
  ::google::protobuf::uint32 param() const;
  void set_param(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:protoduck.ProcedureCmd)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int arm_id_;
  int procedure_;
  ::google::protobuf::uint32 param_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ProcedureCmd* default_instance_;
};
// -------------------------------------------------------------------

class ProcedureStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.ProcedureStatus) */ {
 public:
  ProcedureStatus();
  virtual ~ProcedureStatus();

  ProcedureStatus(const ProcedureStatus& from);

  inline ProcedureStatus& operator=(const ProcedureStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ProcedureStatus& default_instance();

  void Swap(ProcedureStatus* other);

  // implements Message ----------------------------------------------

  inline ProcedureStatus* New() const { return New(NULL); }

  ProcedureStatus* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ProcedureStatus& from);
  void MergeFrom(const ProcedureStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ProcedureStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef ProcedureStatus_Status Status;
  static const Status SUCCESS =
    ProcedureStatus_Status_SUCCESS;
  static const Status RUNNING =
    ProcedureStatus_Status_RUNNING;
  static const Status FAILURE =
    ProcedureStatus_Status_FAILURE;
  static const Status POSITION_UNREACHABLE =
    ProcedureStatus_Status_POSITION_UNREACHABLE;
  static const Status UNABLE_VACUUM =
    ProcedureStatus_Status_UNABLE_VACUUM;
  static inline bool Status_IsValid(int value) {
    return ProcedureStatus_Status_IsValid(value);
  }
  static const Status Status_MIN =
    ProcedureStatus_Status_Status_MIN;
  static const Status Status_MAX =
    ProcedureStatus_Status_Status_MAX;
  static const int Status_ARRAYSIZE =
    ProcedureStatus_Status_Status_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Status_descriptor() {
    return ProcedureStatus_Status_descriptor();
  }
  static inline const ::std::string& Status_Name(Status value) {
    return ProcedureStatus_Status_Name(value);
  }
  static inline bool Status_Parse(const ::std::string& name,
      Status* value) {
    return ProcedureStatus_Status_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protoduck.ProcedureStatus.Status status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  ::protoduck::ProcedureStatus_Status status() const;
  void set_status(::protoduck::ProcedureStatus_Status value);

  // @@protoc_insertion_point(class_scope:protoduck.ProcedureStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static ProcedureStatus* default_instance_;
};
// -------------------------------------------------------------------

class HexaPos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.HexaPos) */ {
 public:
  HexaPos();
  virtual ~HexaPos();

  HexaPos(const HexaPos& from);

  inline HexaPos& operator=(const HexaPos& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HexaPos& default_instance();

  void Swap(HexaPos* other);

  // implements Message ----------------------------------------------

  inline HexaPos* New() const { return New(NULL); }

  HexaPos* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HexaPos& from);
  void MergeFrom(const HexaPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HexaPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HexaPos_HexaType HexaType;
  static const HexaType ROCK =
    HexaPos_HexaType_ROCK;
  static const HexaType RED =
    HexaPos_HexaType_RED;
  static const HexaType GREEN =
    HexaPos_HexaType_GREEN;
  static const HexaType BLUE =
    HexaPos_HexaType_BLUE;
  static inline bool HexaType_IsValid(int value) {
    return HexaPos_HexaType_IsValid(value);
  }
  static const HexaType HexaType_MIN =
    HexaPos_HexaType_HexaType_MIN;
  static const HexaType HexaType_MAX =
    HexaPos_HexaType_HexaType_MAX;
  static const int HexaType_ARRAYSIZE =
    HexaPos_HexaType_HexaType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HexaType_descriptor() {
    return HexaPos_HexaType_descriptor();
  }
  static inline const ::std::string& HexaType_Name(HexaType value) {
    return HexaPos_HexaType_Name(value);
  }
  static inline bool HexaType_Parse(const ::std::string& name,
      HexaType* value) {
    return HexaPos_HexaType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protoduck.HexaPos.HexaType type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::protoduck::HexaPos_HexaType type() const;
  void set_type(::protoduck::HexaPos_HexaType value);

  // optional .protoduck.Pos pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::protoduck::Pos& pos() const;
  ::protoduck::Pos* mutable_pos();
  ::protoduck::Pos* release_pos();
  void set_allocated_pos(::protoduck::Pos* pos);

  // @@protoc_insertion_point(class_scope:protoduck.HexaPos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protoduck::Pos* pos_;
  int type_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static HexaPos* default_instance_;
};
// -------------------------------------------------------------------

class PlayerPos : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.PlayerPos) */ {
 public:
  PlayerPos();
  virtual ~PlayerPos();

  PlayerPos(const PlayerPos& from);

  inline PlayerPos& operator=(const PlayerPos& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PlayerPos& default_instance();

  void Swap(PlayerPos* other);

  // implements Message ----------------------------------------------

  inline PlayerPos* New() const { return New(NULL); }

  PlayerPos* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PlayerPos& from);
  void MergeFrom(const PlayerPos& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PlayerPos* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 aruco_id = 1;
  void clear_aruco_id();
  static const int kArucoIdFieldNumber = 1;
  ::google::protobuf::uint32 aruco_id() const;
  void set_aruco_id(::google::protobuf::uint32 value);

  // optional .protoduck.Pos pos = 2;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 2;
  const ::protoduck::Pos& pos() const;
  ::protoduck::Pos* mutable_pos();
  ::protoduck::Pos* release_pos();
  void set_allocated_pos(::protoduck::Pos* pos);

  // optional .protoduck.Speed speed = 3;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  const ::protoduck::Speed& speed() const;
  ::protoduck::Speed* mutable_speed();
  ::protoduck::Speed* release_speed();
  void set_allocated_speed(::protoduck::Speed* speed);

  // @@protoc_insertion_point(class_scope:protoduck.PlayerPos)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::protoduck::Pos* pos_;
  ::protoduck::Speed* speed_;
  ::google::protobuf::uint32 aruco_id_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static PlayerPos* default_instance_;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:protoduck.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  enum InnerCase {
    kPos = 4,
    kSpeed = 5,
    kMotorsSpeed = 6,
    kMotorsCmd = 7,
    kMotorPid = 8,
    kBat = 9,
    kArm = 10,
    kHat = 11,
    kHmi = 12,
    kProcedureCmd = 13,
    kProcedureStatus = 14,
    kHexaPos = 15,
    kPlayerPos = 16,
    INNER_NOT_SET = 0,
  };

  void Swap(Message* other);

  // implements Message ----------------------------------------------

  inline Message* New() const { return New(NULL); }

  Message* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Message_MsgType MsgType;
  static const MsgType STATUS =
    Message_MsgType_STATUS;
  static const MsgType COMMAND =
    Message_MsgType_COMMAND;
  static inline bool MsgType_IsValid(int value) {
    return Message_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    Message_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    Message_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    Message_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return Message_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return Message_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return Message_MsgType_Parse(name, value);
  }

  typedef Message_Agent Agent;
  static const Agent DIFF =
    Message_Agent_DIFF;
  static const Agent HOLO =
    Message_Agent_HOLO;
  static const Agent RASPI =
    Message_Agent_RASPI;
  static const Agent MAT =
    Message_Agent_MAT;
  static const Agent PC =
    Message_Agent_PC;
  static inline bool Agent_IsValid(int value) {
    return Message_Agent_IsValid(value);
  }
  static const Agent Agent_MIN =
    Message_Agent_Agent_MIN;
  static const Agent Agent_MAX =
    Message_Agent_Agent_MAX;
  static const int Agent_ARRAYSIZE =
    Message_Agent_Agent_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Agent_descriptor() {
    return Message_Agent_descriptor();
  }
  static inline const ::std::string& Agent_Name(Agent value) {
    return Message_Agent_Name(value);
  }
  static inline bool Agent_Parse(const ::std::string& name,
      Agent* value) {
    return Message_Agent_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .protoduck.Message.Agent source = 1;
  void clear_source();
  static const int kSourceFieldNumber = 1;
  ::protoduck::Message_Agent source() const;
  void set_source(::protoduck::Message_Agent value);

  // optional .protoduck.Message.MsgType msg_type = 3;
  void clear_msg_type();
  static const int kMsgTypeFieldNumber = 3;
  ::protoduck::Message_MsgType msg_type() const;
  void set_msg_type(::protoduck::Message_MsgType value);

  // optional .protoduck.Pos pos = 4;
  bool has_pos() const;
  void clear_pos();
  static const int kPosFieldNumber = 4;
  const ::protoduck::Pos& pos() const;
  ::protoduck::Pos* mutable_pos();
  ::protoduck::Pos* release_pos();
  void set_allocated_pos(::protoduck::Pos* pos);

  // optional .protoduck.Speed speed = 5;
  bool has_speed() const;
  void clear_speed();
  static const int kSpeedFieldNumber = 5;
  const ::protoduck::Speed& speed() const;
  ::protoduck::Speed* mutable_speed();
  ::protoduck::Speed* release_speed();
  void set_allocated_speed(::protoduck::Speed* speed);

  // optional .protoduck.MotorsSpeed motors_speed = 6;
  bool has_motors_speed() const;
  void clear_motors_speed();
  static const int kMotorsSpeedFieldNumber = 6;
  const ::protoduck::MotorsSpeed& motors_speed() const;
  ::protoduck::MotorsSpeed* mutable_motors_speed();
  ::protoduck::MotorsSpeed* release_motors_speed();
  void set_allocated_motors_speed(::protoduck::MotorsSpeed* motors_speed);

  // optional .protoduck.MotorsCmd motors_cmd = 7;
  bool has_motors_cmd() const;
  void clear_motors_cmd();
  static const int kMotorsCmdFieldNumber = 7;
  const ::protoduck::MotorsCmd& motors_cmd() const;
  ::protoduck::MotorsCmd* mutable_motors_cmd();
  ::protoduck::MotorsCmd* release_motors_cmd();
  void set_allocated_motors_cmd(::protoduck::MotorsCmd* motors_cmd);

  // optional .protoduck.MotorPid motor_pid = 8;
  bool has_motor_pid() const;
  void clear_motor_pid();
  static const int kMotorPidFieldNumber = 8;
  const ::protoduck::MotorPid& motor_pid() const;
  ::protoduck::MotorPid* mutable_motor_pid();
  ::protoduck::MotorPid* release_motor_pid();
  void set_allocated_motor_pid(::protoduck::MotorPid* motor_pid);

  // optional .protoduck.Bat bat = 9;
  bool has_bat() const;
  void clear_bat();
  static const int kBatFieldNumber = 9;
  const ::protoduck::Bat& bat() const;
  ::protoduck::Bat* mutable_bat();
  ::protoduck::Bat* release_bat();
  void set_allocated_bat(::protoduck::Bat* bat);

  // optional .protoduck.Arm arm = 10;
  bool has_arm() const;
  void clear_arm();
  static const int kArmFieldNumber = 10;
  const ::protoduck::Arm& arm() const;
  ::protoduck::Arm* mutable_arm();
  ::protoduck::Arm* release_arm();
  void set_allocated_arm(::protoduck::Arm* arm);

  // optional .protoduck.Hat hat = 11;
  bool has_hat() const;
  void clear_hat();
  static const int kHatFieldNumber = 11;
  const ::protoduck::Hat& hat() const;
  ::protoduck::Hat* mutable_hat();
  ::protoduck::Hat* release_hat();
  void set_allocated_hat(::protoduck::Hat* hat);

  // optional .protoduck.HMI hmi = 12;
  bool has_hmi() const;
  void clear_hmi();
  static const int kHmiFieldNumber = 12;
  const ::protoduck::HMI& hmi() const;
  ::protoduck::HMI* mutable_hmi();
  ::protoduck::HMI* release_hmi();
  void set_allocated_hmi(::protoduck::HMI* hmi);

  // optional .protoduck.ProcedureCmd procedure_cmd = 13;
  bool has_procedure_cmd() const;
  void clear_procedure_cmd();
  static const int kProcedureCmdFieldNumber = 13;
  const ::protoduck::ProcedureCmd& procedure_cmd() const;
  ::protoduck::ProcedureCmd* mutable_procedure_cmd();
  ::protoduck::ProcedureCmd* release_procedure_cmd();
  void set_allocated_procedure_cmd(::protoduck::ProcedureCmd* procedure_cmd);

  // optional .protoduck.ProcedureStatus procedure_status = 14;
  bool has_procedure_status() const;
  void clear_procedure_status();
  static const int kProcedureStatusFieldNumber = 14;
  const ::protoduck::ProcedureStatus& procedure_status() const;
  ::protoduck::ProcedureStatus* mutable_procedure_status();
  ::protoduck::ProcedureStatus* release_procedure_status();
  void set_allocated_procedure_status(::protoduck::ProcedureStatus* procedure_status);

  // optional .protoduck.HexaPos hexa_pos = 15;
  bool has_hexa_pos() const;
  void clear_hexa_pos();
  static const int kHexaPosFieldNumber = 15;
  const ::protoduck::HexaPos& hexa_pos() const;
  ::protoduck::HexaPos* mutable_hexa_pos();
  ::protoduck::HexaPos* release_hexa_pos();
  void set_allocated_hexa_pos(::protoduck::HexaPos* hexa_pos);

  // optional .protoduck.PlayerPos player_pos = 16;
  bool has_player_pos() const;
  void clear_player_pos();
  static const int kPlayerPosFieldNumber = 16;
  const ::protoduck::PlayerPos& player_pos() const;
  ::protoduck::PlayerPos* mutable_player_pos();
  ::protoduck::PlayerPos* release_player_pos();
  void set_allocated_player_pos(::protoduck::PlayerPos* player_pos);

  InnerCase inner_case() const;
  // @@protoc_insertion_point(class_scope:protoduck.Message)
 private:
  inline void set_has_pos();
  inline void set_has_speed();
  inline void set_has_motors_speed();
  inline void set_has_motors_cmd();
  inline void set_has_motor_pid();
  inline void set_has_bat();
  inline void set_has_arm();
  inline void set_has_hat();
  inline void set_has_hmi();
  inline void set_has_procedure_cmd();
  inline void set_has_procedure_status();
  inline void set_has_hexa_pos();
  inline void set_has_player_pos();

  inline bool has_inner() const;
  void clear_inner();
  inline void clear_has_inner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int source_;
  int msg_type_;
  union InnerUnion {
    InnerUnion() {}
    ::protoduck::Pos* pos_;
    ::protoduck::Speed* speed_;
    ::protoduck::MotorsSpeed* motors_speed_;
    ::protoduck::MotorsCmd* motors_cmd_;
    ::protoduck::MotorPid* motor_pid_;
    ::protoduck::Bat* bat_;
    ::protoduck::Arm* arm_;
    ::protoduck::Hat* hat_;
    ::protoduck::HMI* hmi_;
    ::protoduck::ProcedureCmd* procedure_cmd_;
    ::protoduck::ProcedureStatus* procedure_status_;
    ::protoduck::HexaPos* hexa_pos_;
    ::protoduck::PlayerPos* player_pos_;
  } inner_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_messages_2eproto();
  friend void protobuf_AssignDesc_messages_2eproto();
  friend void protobuf_ShutdownFile_messages_2eproto();

  void InitAsDefaultInstance();
  static Message* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// Pos

// optional float x = 1;
inline void Pos::clear_x() {
  x_ = 0;
}
inline float Pos::x() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.x)
  return x_;
}
inline void Pos::set_x(float value) {
  
  x_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.x)
}

// optional float y = 2;
inline void Pos::clear_y() {
  y_ = 0;
}
inline float Pos::y() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.y)
  return y_;
}
inline void Pos::set_y(float value) {
  
  y_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.y)
}

// optional float theta = 3;
inline void Pos::clear_theta() {
  theta_ = 0;
}
inline float Pos::theta() const {
  // @@protoc_insertion_point(field_get:protoduck.Pos.theta)
  return theta_;
}
inline void Pos::set_theta(float value) {
  
  theta_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Pos.theta)
}

// -------------------------------------------------------------------

// Speed

// optional float vx = 1;
inline void Speed::clear_vx() {
  vx_ = 0;
}
inline float Speed::vx() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vx)
  return vx_;
}
inline void Speed::set_vx(float value) {
  
  vx_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vx)
}

// optional float vy = 2;
inline void Speed::clear_vy() {
  vy_ = 0;
}
inline float Speed::vy() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vy)
  return vy_;
}
inline void Speed::set_vy(float value) {
  
  vy_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vy)
}

// optional float vtheta = 3;
inline void Speed::clear_vtheta() {
  vtheta_ = 0;
}
inline float Speed::vtheta() const {
  // @@protoc_insertion_point(field_get:protoduck.Speed.vtheta)
  return vtheta_;
}
inline void Speed::set_vtheta(float value) {
  
  vtheta_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Speed.vtheta)
}

// -------------------------------------------------------------------

// MotorsSpeed

// optional float v1 = 1;
inline void MotorsSpeed::clear_v1() {
  v1_ = 0;
}
inline float MotorsSpeed::v1() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v1)
  return v1_;
}
inline void MotorsSpeed::set_v1(float value) {
  
  v1_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v1)
}

// optional float v2 = 2;
inline void MotorsSpeed::clear_v2() {
  v2_ = 0;
}
inline float MotorsSpeed::v2() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v2)
  return v2_;
}
inline void MotorsSpeed::set_v2(float value) {
  
  v2_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v2)
}

// optional float v3 = 3;
inline void MotorsSpeed::clear_v3() {
  v3_ = 0;
}
inline float MotorsSpeed::v3() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsSpeed.v3)
  return v3_;
}
inline void MotorsSpeed::set_v3(float value) {
  
  v3_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsSpeed.v3)
}

// -------------------------------------------------------------------

// MotorsCmd

// optional float cmd1 = 1;
inline void MotorsCmd::clear_cmd1() {
  cmd1_ = 0;
}
inline float MotorsCmd::cmd1() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd1)
  return cmd1_;
}
inline void MotorsCmd::set_cmd1(float value) {
  
  cmd1_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd1)
}

// optional float cmd2 = 2;
inline void MotorsCmd::clear_cmd2() {
  cmd2_ = 0;
}
inline float MotorsCmd::cmd2() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd2)
  return cmd2_;
}
inline void MotorsCmd::set_cmd2(float value) {
  
  cmd2_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd2)
}

// optional float cmd3 = 3;
inline void MotorsCmd::clear_cmd3() {
  cmd3_ = 0;
}
inline float MotorsCmd::cmd3() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorsCmd.cmd3)
  return cmd3_;
}
inline void MotorsCmd::set_cmd3(float value) {
  
  cmd3_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorsCmd.cmd3)
}

// -------------------------------------------------------------------

// MotorPid

// optional uint32 motor_no = 1;
inline void MotorPid::clear_motor_no() {
  motor_no_ = 0u;
}
inline ::google::protobuf::uint32 MotorPid::motor_no() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.motor_no)
  return motor_no_;
}
inline void MotorPid::set_motor_no(::google::protobuf::uint32 value) {
  
  motor_no_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.motor_no)
}

// optional float feedforward = 2;
inline void MotorPid::clear_feedforward() {
  feedforward_ = 0;
}
inline float MotorPid::feedforward() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.feedforward)
  return feedforward_;
}
inline void MotorPid::set_feedforward(float value) {
  
  feedforward_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.feedforward)
}

// optional float kp = 3;
inline void MotorPid::clear_kp() {
  kp_ = 0;
}
inline float MotorPid::kp() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.kp)
  return kp_;
}
inline void MotorPid::set_kp(float value) {
  
  kp_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.kp)
}

// optional float ki = 4;
inline void MotorPid::clear_ki() {
  ki_ = 0;
}
inline float MotorPid::ki() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.ki)
  return ki_;
}
inline void MotorPid::set_ki(float value) {
  
  ki_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.ki)
}

// optional float kd = 5;
inline void MotorPid::clear_kd() {
  kd_ = 0;
}
inline float MotorPid::kd() const {
  // @@protoc_insertion_point(field_get:protoduck.MotorPid.kd)
  return kd_;
}
inline void MotorPid::set_kd(float value) {
  
  kd_ = value;
  // @@protoc_insertion_point(field_set:protoduck.MotorPid.kd)
}

// -------------------------------------------------------------------

// Bat

// optional float voltage = 1;
inline void Bat::clear_voltage() {
  voltage_ = 0;
}
inline float Bat::voltage() const {
  // @@protoc_insertion_point(field_get:protoduck.Bat.voltage)
  return voltage_;
}
inline void Bat::set_voltage(float value) {
  
  voltage_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Bat.voltage)
}

// -------------------------------------------------------------------

// Arm

// optional .protoduck.ArmID arm_id = 1;
inline void Arm::clear_arm_id() {
  arm_id_ = 0;
}
inline ::protoduck::ArmID Arm::arm_id() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.arm_id)
  return static_cast< ::protoduck::ArmID >(arm_id_);
}
inline void Arm::set_arm_id(::protoduck::ArmID value) {
  
  arm_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.arm_id)
}

// optional float traZ = 2;
inline void Arm::clear_traz() {
  traz_ = 0;
}
inline float Arm::traz() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.traZ)
  return traz_;
}
inline void Arm::set_traz(float value) {
  
  traz_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.traZ)
}

// optional float rotZ = 3;
inline void Arm::clear_rotz() {
  rotz_ = 0;
}
inline float Arm::rotz() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.rotZ)
  return rotz_;
}
inline void Arm::set_rotz(float value) {
  
  rotz_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.rotZ)
}

// optional float rotY = 4;
inline void Arm::clear_roty() {
  roty_ = 0;
}
inline float Arm::roty() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.rotY)
  return roty_;
}
inline void Arm::set_roty(float value) {
  
  roty_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.rotY)
}

// optional bool pump = 5;
inline void Arm::clear_pump() {
  pump_ = false;
}
inline bool Arm::pump() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.pump)
  return pump_;
}
inline void Arm::set_pump(bool value) {
  
  pump_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.pump)
}

// optional bool valve = 6;
inline void Arm::clear_valve() {
  valve_ = false;
}
inline bool Arm::valve() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.valve)
  return valve_;
}
inline void Arm::set_valve(bool value) {
  
  valve_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.valve)
}

// optional float pressure = 7;
inline void Arm::clear_pressure() {
  pressure_ = 0;
}
inline float Arm::pressure() const {
  // @@protoc_insertion_point(field_get:protoduck.Arm.pressure)
  return pressure_;
}
inline void Arm::set_pressure(float value) {
  
  pressure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Arm.pressure)
}

// -------------------------------------------------------------------

// Hat

// optional float height = 1;
inline void Hat::clear_height() {
  height_ = 0;
}
inline float Hat::height() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.height)
  return height_;
}
inline void Hat::set_height(float value) {
  
  height_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.height)
}

// optional bool pump = 2;
inline void Hat::clear_pump() {
  pump_ = false;
}
inline bool Hat::pump() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.pump)
  return pump_;
}
inline void Hat::set_pump(bool value) {
  
  pump_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.pump)
}

// optional bool valve = 3;
inline void Hat::clear_valve() {
  valve_ = false;
}
inline bool Hat::valve() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.valve)
  return valve_;
}
inline void Hat::set_valve(bool value) {
  
  valve_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.valve)
}

// optional float pressure = 4;
inline void Hat::clear_pressure() {
  pressure_ = 0;
}
inline float Hat::pressure() const {
  // @@protoc_insertion_point(field_get:protoduck.Hat.pressure)
  return pressure_;
}
inline void Hat::set_pressure(float value) {
  
  pressure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Hat.pressure)
}

// -------------------------------------------------------------------

// HMI

// optional bool color = 1;
inline void HMI::clear_color() {
  color_ = false;
}
inline bool HMI::color() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.color)
  return color_;
}
inline void HMI::set_color(bool value) {
  
  color_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.color)
}

// optional bool tirette = 2;
inline void HMI::clear_tirette() {
  tirette_ = false;
}
inline bool HMI::tirette() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.tirette)
  return tirette_;
}
inline void HMI::set_tirette(bool value) {
  
  tirette_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.tirette)
}

// optional bool bouton = 3;
inline void HMI::clear_bouton() {
  bouton_ = false;
}
inline bool HMI::bouton() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.bouton)
  return bouton_;
}
inline void HMI::set_bouton(bool value) {
  
  bouton_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.bouton)
}

// optional uint32 led = 4;
inline void HMI::clear_led() {
  led_ = 0u;
}
inline ::google::protobuf::uint32 HMI::led() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.led)
  return led_;
}
inline void HMI::set_led(::google::protobuf::uint32 value) {
  
  led_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.led)
}

// optional uint32 hmi_display = 5;
inline void HMI::clear_hmi_display() {
  hmi_display_ = 0u;
}
inline ::google::protobuf::uint32 HMI::hmi_display() const {
  // @@protoc_insertion_point(field_get:protoduck.HMI.hmi_display)
  return hmi_display_;
}
inline void HMI::set_hmi_display(::google::protobuf::uint32 value) {
  
  hmi_display_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HMI.hmi_display)
}

// -------------------------------------------------------------------

// ProcedureCmd

// optional .protoduck.ArmID arm_id = 1;
inline void ProcedureCmd::clear_arm_id() {
  arm_id_ = 0;
}
inline ::protoduck::ArmID ProcedureCmd::arm_id() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.arm_id)
  return static_cast< ::protoduck::ArmID >(arm_id_);
}
inline void ProcedureCmd::set_arm_id(::protoduck::ArmID value) {
  
  arm_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.arm_id)
}

// optional .protoduck.ProcedureCmd.Procedure procedure = 2;
inline void ProcedureCmd::clear_procedure() {
  procedure_ = 0;
}
inline ::protoduck::ProcedureCmd_Procedure ProcedureCmd::procedure() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.procedure)
  return static_cast< ::protoduck::ProcedureCmd_Procedure >(procedure_);
}
inline void ProcedureCmd::set_procedure(::protoduck::ProcedureCmd_Procedure value) {
  
  procedure_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.procedure)
}

// optional uint32 param = 3;
inline void ProcedureCmd::clear_param() {
  param_ = 0u;
}
inline ::google::protobuf::uint32 ProcedureCmd::param() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureCmd.param)
  return param_;
}
inline void ProcedureCmd::set_param(::google::protobuf::uint32 value) {
  
  param_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureCmd.param)
}

// -------------------------------------------------------------------

// ProcedureStatus

// optional .protoduck.ProcedureStatus.Status status = 1;
inline void ProcedureStatus::clear_status() {
  status_ = 0;
}
inline ::protoduck::ProcedureStatus_Status ProcedureStatus::status() const {
  // @@protoc_insertion_point(field_get:protoduck.ProcedureStatus.status)
  return static_cast< ::protoduck::ProcedureStatus_Status >(status_);
}
inline void ProcedureStatus::set_status(::protoduck::ProcedureStatus_Status value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:protoduck.ProcedureStatus.status)
}

// -------------------------------------------------------------------

// HexaPos

// optional .protoduck.HexaPos.HexaType type = 1;
inline void HexaPos::clear_type() {
  type_ = 0;
}
inline ::protoduck::HexaPos_HexaType HexaPos::type() const {
  // @@protoc_insertion_point(field_get:protoduck.HexaPos.type)
  return static_cast< ::protoduck::HexaPos_HexaType >(type_);
}
inline void HexaPos::set_type(::protoduck::HexaPos_HexaType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:protoduck.HexaPos.type)
}

// optional .protoduck.Pos pos = 2;
inline bool HexaPos::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
inline void HexaPos::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::protoduck::Pos& HexaPos::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.HexaPos.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::protoduck::Pos* HexaPos::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.HexaPos.pos)
  return pos_;
}
inline ::protoduck::Pos* HexaPos::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.HexaPos.pos)
  
  ::protoduck::Pos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void HexaPos::set_allocated_pos(::protoduck::Pos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.HexaPos.pos)
}

// -------------------------------------------------------------------

// PlayerPos

// optional uint32 aruco_id = 1;
inline void PlayerPos::clear_aruco_id() {
  aruco_id_ = 0u;
}
inline ::google::protobuf::uint32 PlayerPos::aruco_id() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.aruco_id)
  return aruco_id_;
}
inline void PlayerPos::set_aruco_id(::google::protobuf::uint32 value) {
  
  aruco_id_ = value;
  // @@protoc_insertion_point(field_set:protoduck.PlayerPos.aruco_id)
}

// optional .protoduck.Pos pos = 2;
inline bool PlayerPos::has_pos() const {
  return !_is_default_instance_ && pos_ != NULL;
}
inline void PlayerPos::clear_pos() {
  if (GetArenaNoVirtual() == NULL && pos_ != NULL) delete pos_;
  pos_ = NULL;
}
inline const ::protoduck::Pos& PlayerPos::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.pos)
  return pos_ != NULL ? *pos_ : *default_instance_->pos_;
}
inline ::protoduck::Pos* PlayerPos::mutable_pos() {
  
  if (pos_ == NULL) {
    pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.PlayerPos.pos)
  return pos_;
}
inline ::protoduck::Pos* PlayerPos::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.PlayerPos.pos)
  
  ::protoduck::Pos* temp = pos_;
  pos_ = NULL;
  return temp;
}
inline void PlayerPos::set_allocated_pos(::protoduck::Pos* pos) {
  delete pos_;
  pos_ = pos;
  if (pos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.PlayerPos.pos)
}

// optional .protoduck.Speed speed = 3;
inline bool PlayerPos::has_speed() const {
  return !_is_default_instance_ && speed_ != NULL;
}
inline void PlayerPos::clear_speed() {
  if (GetArenaNoVirtual() == NULL && speed_ != NULL) delete speed_;
  speed_ = NULL;
}
inline const ::protoduck::Speed& PlayerPos::speed() const {
  // @@protoc_insertion_point(field_get:protoduck.PlayerPos.speed)
  return speed_ != NULL ? *speed_ : *default_instance_->speed_;
}
inline ::protoduck::Speed* PlayerPos::mutable_speed() {
  
  if (speed_ == NULL) {
    speed_ = new ::protoduck::Speed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.PlayerPos.speed)
  return speed_;
}
inline ::protoduck::Speed* PlayerPos::release_speed() {
  // @@protoc_insertion_point(field_release:protoduck.PlayerPos.speed)
  
  ::protoduck::Speed* temp = speed_;
  speed_ = NULL;
  return temp;
}
inline void PlayerPos::set_allocated_speed(::protoduck::Speed* speed) {
  delete speed_;
  speed_ = speed;
  if (speed) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.PlayerPos.speed)
}

// -------------------------------------------------------------------

// Message

// optional .protoduck.Message.Agent source = 1;
inline void Message::clear_source() {
  source_ = 0;
}
inline ::protoduck::Message_Agent Message::source() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.source)
  return static_cast< ::protoduck::Message_Agent >(source_);
}
inline void Message::set_source(::protoduck::Message_Agent value) {
  
  source_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Message.source)
}

// optional .protoduck.Message.MsgType msg_type = 3;
inline void Message::clear_msg_type() {
  msg_type_ = 0;
}
inline ::protoduck::Message_MsgType Message::msg_type() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.msg_type)
  return static_cast< ::protoduck::Message_MsgType >(msg_type_);
}
inline void Message::set_msg_type(::protoduck::Message_MsgType value) {
  
  msg_type_ = value;
  // @@protoc_insertion_point(field_set:protoduck.Message.msg_type)
}

// optional .protoduck.Pos pos = 4;
inline bool Message::has_pos() const {
  return inner_case() == kPos;
}
inline void Message::set_has_pos() {
  _oneof_case_[0] = kPos;
}
inline void Message::clear_pos() {
  if (has_pos()) {
    delete inner_.pos_;
    clear_has_inner();
  }
}
inline  const ::protoduck::Pos& Message::pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.pos)
  return has_pos()
      ? *inner_.pos_
      : ::protoduck::Pos::default_instance();
}
inline ::protoduck::Pos* Message::mutable_pos() {
  if (!has_pos()) {
    clear_inner();
    set_has_pos();
    inner_.pos_ = new ::protoduck::Pos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.pos)
  return inner_.pos_;
}
inline ::protoduck::Pos* Message::release_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.pos)
  if (has_pos()) {
    clear_has_inner();
    ::protoduck::Pos* temp = inner_.pos_;
    inner_.pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_pos(::protoduck::Pos* pos) {
  clear_inner();
  if (pos) {
    set_has_pos();
    inner_.pos_ = pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.pos)
}

// optional .protoduck.Speed speed = 5;
inline bool Message::has_speed() const {
  return inner_case() == kSpeed;
}
inline void Message::set_has_speed() {
  _oneof_case_[0] = kSpeed;
}
inline void Message::clear_speed() {
  if (has_speed()) {
    delete inner_.speed_;
    clear_has_inner();
  }
}
inline  const ::protoduck::Speed& Message::speed() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.speed)
  return has_speed()
      ? *inner_.speed_
      : ::protoduck::Speed::default_instance();
}
inline ::protoduck::Speed* Message::mutable_speed() {
  if (!has_speed()) {
    clear_inner();
    set_has_speed();
    inner_.speed_ = new ::protoduck::Speed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.speed)
  return inner_.speed_;
}
inline ::protoduck::Speed* Message::release_speed() {
  // @@protoc_insertion_point(field_release:protoduck.Message.speed)
  if (has_speed()) {
    clear_has_inner();
    ::protoduck::Speed* temp = inner_.speed_;
    inner_.speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_speed(::protoduck::Speed* speed) {
  clear_inner();
  if (speed) {
    set_has_speed();
    inner_.speed_ = speed;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.speed)
}

// optional .protoduck.MotorsSpeed motors_speed = 6;
inline bool Message::has_motors_speed() const {
  return inner_case() == kMotorsSpeed;
}
inline void Message::set_has_motors_speed() {
  _oneof_case_[0] = kMotorsSpeed;
}
inline void Message::clear_motors_speed() {
  if (has_motors_speed()) {
    delete inner_.motors_speed_;
    clear_has_inner();
  }
}
inline  const ::protoduck::MotorsSpeed& Message::motors_speed() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motors_speed)
  return has_motors_speed()
      ? *inner_.motors_speed_
      : ::protoduck::MotorsSpeed::default_instance();
}
inline ::protoduck::MotorsSpeed* Message::mutable_motors_speed() {
  if (!has_motors_speed()) {
    clear_inner();
    set_has_motors_speed();
    inner_.motors_speed_ = new ::protoduck::MotorsSpeed;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motors_speed)
  return inner_.motors_speed_;
}
inline ::protoduck::MotorsSpeed* Message::release_motors_speed() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motors_speed)
  if (has_motors_speed()) {
    clear_has_inner();
    ::protoduck::MotorsSpeed* temp = inner_.motors_speed_;
    inner_.motors_speed_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_motors_speed(::protoduck::MotorsSpeed* motors_speed) {
  clear_inner();
  if (motors_speed) {
    set_has_motors_speed();
    inner_.motors_speed_ = motors_speed;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motors_speed)
}

// optional .protoduck.MotorsCmd motors_cmd = 7;
inline bool Message::has_motors_cmd() const {
  return inner_case() == kMotorsCmd;
}
inline void Message::set_has_motors_cmd() {
  _oneof_case_[0] = kMotorsCmd;
}
inline void Message::clear_motors_cmd() {
  if (has_motors_cmd()) {
    delete inner_.motors_cmd_;
    clear_has_inner();
  }
}
inline  const ::protoduck::MotorsCmd& Message::motors_cmd() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motors_cmd)
  return has_motors_cmd()
      ? *inner_.motors_cmd_
      : ::protoduck::MotorsCmd::default_instance();
}
inline ::protoduck::MotorsCmd* Message::mutable_motors_cmd() {
  if (!has_motors_cmd()) {
    clear_inner();
    set_has_motors_cmd();
    inner_.motors_cmd_ = new ::protoduck::MotorsCmd;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motors_cmd)
  return inner_.motors_cmd_;
}
inline ::protoduck::MotorsCmd* Message::release_motors_cmd() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motors_cmd)
  if (has_motors_cmd()) {
    clear_has_inner();
    ::protoduck::MotorsCmd* temp = inner_.motors_cmd_;
    inner_.motors_cmd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_motors_cmd(::protoduck::MotorsCmd* motors_cmd) {
  clear_inner();
  if (motors_cmd) {
    set_has_motors_cmd();
    inner_.motors_cmd_ = motors_cmd;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motors_cmd)
}

// optional .protoduck.MotorPid motor_pid = 8;
inline bool Message::has_motor_pid() const {
  return inner_case() == kMotorPid;
}
inline void Message::set_has_motor_pid() {
  _oneof_case_[0] = kMotorPid;
}
inline void Message::clear_motor_pid() {
  if (has_motor_pid()) {
    delete inner_.motor_pid_;
    clear_has_inner();
  }
}
inline  const ::protoduck::MotorPid& Message::motor_pid() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.motor_pid)
  return has_motor_pid()
      ? *inner_.motor_pid_
      : ::protoduck::MotorPid::default_instance();
}
inline ::protoduck::MotorPid* Message::mutable_motor_pid() {
  if (!has_motor_pid()) {
    clear_inner();
    set_has_motor_pid();
    inner_.motor_pid_ = new ::protoduck::MotorPid;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.motor_pid)
  return inner_.motor_pid_;
}
inline ::protoduck::MotorPid* Message::release_motor_pid() {
  // @@protoc_insertion_point(field_release:protoduck.Message.motor_pid)
  if (has_motor_pid()) {
    clear_has_inner();
    ::protoduck::MotorPid* temp = inner_.motor_pid_;
    inner_.motor_pid_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_motor_pid(::protoduck::MotorPid* motor_pid) {
  clear_inner();
  if (motor_pid) {
    set_has_motor_pid();
    inner_.motor_pid_ = motor_pid;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.motor_pid)
}

// optional .protoduck.Bat bat = 9;
inline bool Message::has_bat() const {
  return inner_case() == kBat;
}
inline void Message::set_has_bat() {
  _oneof_case_[0] = kBat;
}
inline void Message::clear_bat() {
  if (has_bat()) {
    delete inner_.bat_;
    clear_has_inner();
  }
}
inline  const ::protoduck::Bat& Message::bat() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.bat)
  return has_bat()
      ? *inner_.bat_
      : ::protoduck::Bat::default_instance();
}
inline ::protoduck::Bat* Message::mutable_bat() {
  if (!has_bat()) {
    clear_inner();
    set_has_bat();
    inner_.bat_ = new ::protoduck::Bat;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.bat)
  return inner_.bat_;
}
inline ::protoduck::Bat* Message::release_bat() {
  // @@protoc_insertion_point(field_release:protoduck.Message.bat)
  if (has_bat()) {
    clear_has_inner();
    ::protoduck::Bat* temp = inner_.bat_;
    inner_.bat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_bat(::protoduck::Bat* bat) {
  clear_inner();
  if (bat) {
    set_has_bat();
    inner_.bat_ = bat;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.bat)
}

// optional .protoduck.Arm arm = 10;
inline bool Message::has_arm() const {
  return inner_case() == kArm;
}
inline void Message::set_has_arm() {
  _oneof_case_[0] = kArm;
}
inline void Message::clear_arm() {
  if (has_arm()) {
    delete inner_.arm_;
    clear_has_inner();
  }
}
inline  const ::protoduck::Arm& Message::arm() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.arm)
  return has_arm()
      ? *inner_.arm_
      : ::protoduck::Arm::default_instance();
}
inline ::protoduck::Arm* Message::mutable_arm() {
  if (!has_arm()) {
    clear_inner();
    set_has_arm();
    inner_.arm_ = new ::protoduck::Arm;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.arm)
  return inner_.arm_;
}
inline ::protoduck::Arm* Message::release_arm() {
  // @@protoc_insertion_point(field_release:protoduck.Message.arm)
  if (has_arm()) {
    clear_has_inner();
    ::protoduck::Arm* temp = inner_.arm_;
    inner_.arm_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_arm(::protoduck::Arm* arm) {
  clear_inner();
  if (arm) {
    set_has_arm();
    inner_.arm_ = arm;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.arm)
}

// optional .protoduck.Hat hat = 11;
inline bool Message::has_hat() const {
  return inner_case() == kHat;
}
inline void Message::set_has_hat() {
  _oneof_case_[0] = kHat;
}
inline void Message::clear_hat() {
  if (has_hat()) {
    delete inner_.hat_;
    clear_has_inner();
  }
}
inline  const ::protoduck::Hat& Message::hat() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hat)
  return has_hat()
      ? *inner_.hat_
      : ::protoduck::Hat::default_instance();
}
inline ::protoduck::Hat* Message::mutable_hat() {
  if (!has_hat()) {
    clear_inner();
    set_has_hat();
    inner_.hat_ = new ::protoduck::Hat;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hat)
  return inner_.hat_;
}
inline ::protoduck::Hat* Message::release_hat() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hat)
  if (has_hat()) {
    clear_has_inner();
    ::protoduck::Hat* temp = inner_.hat_;
    inner_.hat_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_hat(::protoduck::Hat* hat) {
  clear_inner();
  if (hat) {
    set_has_hat();
    inner_.hat_ = hat;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hat)
}

// optional .protoduck.HMI hmi = 12;
inline bool Message::has_hmi() const {
  return inner_case() == kHmi;
}
inline void Message::set_has_hmi() {
  _oneof_case_[0] = kHmi;
}
inline void Message::clear_hmi() {
  if (has_hmi()) {
    delete inner_.hmi_;
    clear_has_inner();
  }
}
inline  const ::protoduck::HMI& Message::hmi() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hmi)
  return has_hmi()
      ? *inner_.hmi_
      : ::protoduck::HMI::default_instance();
}
inline ::protoduck::HMI* Message::mutable_hmi() {
  if (!has_hmi()) {
    clear_inner();
    set_has_hmi();
    inner_.hmi_ = new ::protoduck::HMI;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hmi)
  return inner_.hmi_;
}
inline ::protoduck::HMI* Message::release_hmi() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hmi)
  if (has_hmi()) {
    clear_has_inner();
    ::protoduck::HMI* temp = inner_.hmi_;
    inner_.hmi_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_hmi(::protoduck::HMI* hmi) {
  clear_inner();
  if (hmi) {
    set_has_hmi();
    inner_.hmi_ = hmi;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hmi)
}

// optional .protoduck.ProcedureCmd procedure_cmd = 13;
inline bool Message::has_procedure_cmd() const {
  return inner_case() == kProcedureCmd;
}
inline void Message::set_has_procedure_cmd() {
  _oneof_case_[0] = kProcedureCmd;
}
inline void Message::clear_procedure_cmd() {
  if (has_procedure_cmd()) {
    delete inner_.procedure_cmd_;
    clear_has_inner();
  }
}
inline  const ::protoduck::ProcedureCmd& Message::procedure_cmd() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.procedure_cmd)
  return has_procedure_cmd()
      ? *inner_.procedure_cmd_
      : ::protoduck::ProcedureCmd::default_instance();
}
inline ::protoduck::ProcedureCmd* Message::mutable_procedure_cmd() {
  if (!has_procedure_cmd()) {
    clear_inner();
    set_has_procedure_cmd();
    inner_.procedure_cmd_ = new ::protoduck::ProcedureCmd;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.procedure_cmd)
  return inner_.procedure_cmd_;
}
inline ::protoduck::ProcedureCmd* Message::release_procedure_cmd() {
  // @@protoc_insertion_point(field_release:protoduck.Message.procedure_cmd)
  if (has_procedure_cmd()) {
    clear_has_inner();
    ::protoduck::ProcedureCmd* temp = inner_.procedure_cmd_;
    inner_.procedure_cmd_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_procedure_cmd(::protoduck::ProcedureCmd* procedure_cmd) {
  clear_inner();
  if (procedure_cmd) {
    set_has_procedure_cmd();
    inner_.procedure_cmd_ = procedure_cmd;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.procedure_cmd)
}

// optional .protoduck.ProcedureStatus procedure_status = 14;
inline bool Message::has_procedure_status() const {
  return inner_case() == kProcedureStatus;
}
inline void Message::set_has_procedure_status() {
  _oneof_case_[0] = kProcedureStatus;
}
inline void Message::clear_procedure_status() {
  if (has_procedure_status()) {
    delete inner_.procedure_status_;
    clear_has_inner();
  }
}
inline  const ::protoduck::ProcedureStatus& Message::procedure_status() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.procedure_status)
  return has_procedure_status()
      ? *inner_.procedure_status_
      : ::protoduck::ProcedureStatus::default_instance();
}
inline ::protoduck::ProcedureStatus* Message::mutable_procedure_status() {
  if (!has_procedure_status()) {
    clear_inner();
    set_has_procedure_status();
    inner_.procedure_status_ = new ::protoduck::ProcedureStatus;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.procedure_status)
  return inner_.procedure_status_;
}
inline ::protoduck::ProcedureStatus* Message::release_procedure_status() {
  // @@protoc_insertion_point(field_release:protoduck.Message.procedure_status)
  if (has_procedure_status()) {
    clear_has_inner();
    ::protoduck::ProcedureStatus* temp = inner_.procedure_status_;
    inner_.procedure_status_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_procedure_status(::protoduck::ProcedureStatus* procedure_status) {
  clear_inner();
  if (procedure_status) {
    set_has_procedure_status();
    inner_.procedure_status_ = procedure_status;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.procedure_status)
}

// optional .protoduck.HexaPos hexa_pos = 15;
inline bool Message::has_hexa_pos() const {
  return inner_case() == kHexaPos;
}
inline void Message::set_has_hexa_pos() {
  _oneof_case_[0] = kHexaPos;
}
inline void Message::clear_hexa_pos() {
  if (has_hexa_pos()) {
    delete inner_.hexa_pos_;
    clear_has_inner();
  }
}
inline  const ::protoduck::HexaPos& Message::hexa_pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.hexa_pos)
  return has_hexa_pos()
      ? *inner_.hexa_pos_
      : ::protoduck::HexaPos::default_instance();
}
inline ::protoduck::HexaPos* Message::mutable_hexa_pos() {
  if (!has_hexa_pos()) {
    clear_inner();
    set_has_hexa_pos();
    inner_.hexa_pos_ = new ::protoduck::HexaPos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.hexa_pos)
  return inner_.hexa_pos_;
}
inline ::protoduck::HexaPos* Message::release_hexa_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.hexa_pos)
  if (has_hexa_pos()) {
    clear_has_inner();
    ::protoduck::HexaPos* temp = inner_.hexa_pos_;
    inner_.hexa_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_hexa_pos(::protoduck::HexaPos* hexa_pos) {
  clear_inner();
  if (hexa_pos) {
    set_has_hexa_pos();
    inner_.hexa_pos_ = hexa_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.hexa_pos)
}

// optional .protoduck.PlayerPos player_pos = 16;
inline bool Message::has_player_pos() const {
  return inner_case() == kPlayerPos;
}
inline void Message::set_has_player_pos() {
  _oneof_case_[0] = kPlayerPos;
}
inline void Message::clear_player_pos() {
  if (has_player_pos()) {
    delete inner_.player_pos_;
    clear_has_inner();
  }
}
inline  const ::protoduck::PlayerPos& Message::player_pos() const {
  // @@protoc_insertion_point(field_get:protoduck.Message.player_pos)
  return has_player_pos()
      ? *inner_.player_pos_
      : ::protoduck::PlayerPos::default_instance();
}
inline ::protoduck::PlayerPos* Message::mutable_player_pos() {
  if (!has_player_pos()) {
    clear_inner();
    set_has_player_pos();
    inner_.player_pos_ = new ::protoduck::PlayerPos;
  }
  // @@protoc_insertion_point(field_mutable:protoduck.Message.player_pos)
  return inner_.player_pos_;
}
inline ::protoduck::PlayerPos* Message::release_player_pos() {
  // @@protoc_insertion_point(field_release:protoduck.Message.player_pos)
  if (has_player_pos()) {
    clear_has_inner();
    ::protoduck::PlayerPos* temp = inner_.player_pos_;
    inner_.player_pos_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Message::set_allocated_player_pos(::protoduck::PlayerPos* player_pos) {
  clear_inner();
  if (player_pos) {
    set_has_player_pos();
    inner_.player_pos_ = player_pos;
  }
  // @@protoc_insertion_point(field_set_allocated:protoduck.Message.player_pos)
}

inline bool Message::has_inner() const {
  return inner_case() != INNER_NOT_SET;
}
inline void Message::clear_has_inner() {
  _oneof_case_[0] = INNER_NOT_SET;
}
inline Message::InnerCase Message::inner_case() const {
  return Message::InnerCase(_oneof_case_[0]);
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protoduck

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::protoduck::ProcedureCmd_Procedure> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::ProcedureCmd_Procedure>() {
  return ::protoduck::ProcedureCmd_Procedure_descriptor();
}
template <> struct is_proto_enum< ::protoduck::ProcedureStatus_Status> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::ProcedureStatus_Status>() {
  return ::protoduck::ProcedureStatus_Status_descriptor();
}
template <> struct is_proto_enum< ::protoduck::HexaPos_HexaType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::HexaPos_HexaType>() {
  return ::protoduck::HexaPos_HexaType_descriptor();
}
template <> struct is_proto_enum< ::protoduck::Message_MsgType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::Message_MsgType>() {
  return ::protoduck::Message_MsgType_descriptor();
}
template <> struct is_proto_enum< ::protoduck::Message_Agent> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::Message_Agent>() {
  return ::protoduck::Message_Agent_descriptor();
}
template <> struct is_proto_enum< ::protoduck::ArmID> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::protoduck::ArmID>() {
  return ::protoduck::ArmID_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
